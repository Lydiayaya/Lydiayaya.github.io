<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-12T14:54:01.893Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红松学堂</title>
    <link href="http://example.com/2022/04/12/%E7%BA%A2%E6%9D%BE%E5%AD%A6%E5%A0%82/"/>
    <id>http://example.com/2022/04/12/%E7%BA%A2%E6%9D%BE%E5%AD%A6%E5%A0%82/</id>
    <published>2022-04-12T14:48:23.000Z</published>
    <updated>2022-04-12T14:54:01.893Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>*红松2022年校园招聘-前端笔试*</strong></em></p><p><em><strong>*单选题*</strong></em></p><ol><li>如下js代码会输出什么？（ A  ） C</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">await</span> fun2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">9</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>)    </span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">  &#125;).then(() = &gt;&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>);  </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line"><span class="comment">//为什么 7要比3后  </span></span><br></pre></td></tr></table></figure><p>选项：</p><p>A、1 6 2 8 3 5 7 9 4</p><p>B、1 6 2 3 5 8 7 9 4</p><p>C、1 6 2 8 3 7 5 9 4</p><p>D、1 6 2 7 8 3 5 9 4</p><ol start="2"><li>以下代码执行的结果是（ D  ）</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JavaScript</span><br><span class="line"><span class="keyword">var</span> arr = [&#123;<span class="attr">old</span>: <span class="string">&#x27;old&#x27;</span>&#125;, [<span class="string">&#x27;old&#x27;</span>], <span class="string">&#x27;old&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> new_arr = arr.concat();</span><br><span class="line">arr[<span class="number">0</span>].old = <span class="string">&#x27;new&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="string">&#x27;new&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="built_in">console</span>.log(new_arr);</span><br></pre></td></tr></table></figure><p>选项：</p><p>A、[{old: ‘old’}, [‘old’], ‘old’], [{old: ‘old’}, [‘old’], ‘old’]</p><p>B、[{old: ‘old’}, [‘old’], ‘new’], [{old: ‘new’}, [‘new’], ‘new’]</p><p>C、[{old: ‘new’}, [‘new’], ‘new’], [{old: ‘new’}, [‘new’], ‘new’]</p><p>D、[{old: ‘new’}, [‘new’], ‘old’], [{old: ‘new’}, [‘new’], ‘old’]</p><p>\3. 分别以下列序列构造二叉排序树，层次遍历序列与用其它三个结果不同的是（D）</p><p>A、（100，80，90，140，50，120，160)</p><p>B、（100，140，160，120，80，50，90）</p><p>C、（100，80，50，90，140，160，120）</p><p>D、（100，50，90，80，120，140，160）</p><p>二叉排序树：左边孩子必须小于根节点，右边孩子必须大于根节点；孩子也是二叉排序树；依次排列小于根节点和大于根节点的。</p><p>\4. 以下代码的执行结果是（ C） B</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animal.price = <span class="number">1000</span>;</span><br><span class="line">Animal.prototype.price = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">Dog.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> cat = Animal;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.dir(dog.price);</span><br><span class="line"><span class="built_in">console</span>.log(cat.price);</span><br><span class="line"><span class="comment">//画原型图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">animal.prototype.price = <span class="number">20</span>;</span><br><span class="line">animal.price = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">dog.prototype = animal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> animal();</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="comment">// 下面两行分别输出什么？</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.price);<span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(tidy.price);<span class="comment">//1000</span></span><br></pre></td></tr></table></figure><p>A、20, 20</p><p>B、20, 1000</p><p>C、1000, 1000</p><p>D、1000, 20</p><p>\5. 设有4个同时到达的作业A1，A2，A3和A4，各作业所需要的执行时间分别是S1，S2，S3和S4，且S1&lt;S2&lt;S3&lt;S4,若系统采用单道方式运行且采用短作业优先调度算法，则平均周转时间是（ D  ）。</p><p>A、S1+S2+S3+S4</p><p>B、(S1+2S2+3S3+4S4)/4</p><p>C、(S1+S2+S3+S4)/4</p><p>D、(4S1+3S2+2S3+S4)/4</p><p>根据短作业优先调度算法，可以知道调度顺序是J1, J2, J3因此J1先执行, J2, J3等待T1的时间；然后J2执行，J3继续等待T2的时间；最后J3执行T3时间。因此J1的周转时间为T1，J2的周转时间为T1 + T2，J3的周转时间为T1 + T2 + T3；平均周转时间为三者只和的平均值，即(3T1 + 2T2 +T3) / 3</p><p><a href="https://www.cnblogs.com/mrmrwjk/p/14697787.html">通过几个例题理解进程周转时间问题 - JK~ - 博客园 (cnblogs.com)</a></p><p>\6. 执行以下代码，最终son盒子的width值是（D）px</p><p>深入理解父元素与子元素的width关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.father &#123;</span><br><span class="line">    <span class="attr">width</span>: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">    <span class="attr">margin</span>:<span class="number">0</span> -5px;</span><br><span class="line">    padding:<span class="number">0</span> 10px;</span><br><span class="line">    height:100px;<span class="comment">//设置高度未设置宽度，子元素的宽度为父元素的100%，块级元素，子元素的宽度默认为父元素的100%</span></span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;father&quot;</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>A、200</p><p>B、190</p><p>C、170</p><p>D、210</p><p>\7. 根据以下html和css代码，son盒子所属的包含块是（D）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.grandfather &#123;</span><br><span class="line">     position:relative;</span><br><span class="line">     top:50px;</span><br><span class="line">     left:50px;</span><br><span class="line">     width:200px;</span><br><span class="line">     height:200px;</span><br><span class="line">     background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">.father &#123;</span><br><span class="line">     position:relative;</span><br><span class="line">     width:100px;</span><br><span class="line">     height:100px;</span><br><span class="line">     background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">    position:fixed;</span><br><span class="line">    width:50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    left:10px;</span><br><span class="line">    top:10px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grandfather&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>A、grandfather盒子  </p><p>B、father盒子 </p><p>C、son盒子 </p><p>D、viewport（当前可视窗口）</p><p>\8. 以下选项中，不符合HTML5代码要求的是（C）</p><p>A、<div>这里是div盒子</div></p><p>B、&lt;inputtype=”text”  readonly&gt;</p><p>C、<div class="box" wrapper> 但是这个是错的啊</div></p><p>D、<div class="div"></div></p><p><a href="https://www.runoob.com/html/html5-syntax.html">HTML(5) 代码规范 | 菜鸟教程 (runoob.com)</a></p><p>\9. 假设有一个箱子，箱子里面有10个乒乓球，其中有4个是黄球，6个是白球，从中任取两个球，已知两个球中有一个球为黄球，那么另一个球也是黄球的概率为（A）C</p><p>A、1/2</p><p>B、2/3</p><p>C、1/5</p><p>D、2/5</p><p><img src="/2022/04/12/%E7%BA%A2%E6%9D%BE%E5%AD%A6%E5%A0%82/wps1.jpg" alt="img"> </p><p><strong>多选题</strong> </p><ol start="10"><li>下面说法正确的是（BC） ABD</li></ol><p>A、样式文件的加载会阻塞脚本的执行</p><p>B、iframe 会阻塞主页面的 load 事件</p><p>C、<audio>、<img> 中的资源下载会阻塞页面解析</audio></p><p>D、页面文档完全加载并解析完毕之后会触发 DOMContentLoaded 事件</p><p><strong>当初始HTML文档已完全加载和解析时，将触发DOMContentLoaded事件，而不需要等待样式表，图像和子框架页面加载（事件可以用来检测HTML页面是否完全加载完毕(fully-loaded)）。</strong></p><p>\11. 下列说法错误的是（AB）</p><p>A、当前域的 cookie 都可以通过 js 在当前域下获取</p><p><strong>对于一些保密性较高的 cookie 后端可以通过设置 HttpOnly 标记 cookie 只能通过 http 传递，前端 js 无法读取，这样可以防范xss攻击。</strong></p><p>B、 JSONP 是 XMLHttpRequest 中的一种</p><p><strong>JSONP 用的是 html 的 script 标签，xmlhttprequest 是浏览器内置的 HTTP 相关对象，两者不同。</strong></p><p>C、同源策略是浏览器的安全策略</p><p>D、localStorage API 不支持设置过期时间</p><p>\12. 下列说法正确的是（A,D）ACD</p><p>A、requestAnimationFrame(foo) 确保使浏览器在下一次重绘之前调用 foo 方法<strong>window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。</strong></p><p>B、在 addEventListener 的处理方法中使用 e.preventDefault() 可以阻止事件冒泡</p><p><strong>e.stopPropagation()，阻止事件冒泡</strong></p><p>C、 把 <script> 标签的引入放在文档末尾可以确保脚本下载和执行均在文档解析完成后发生</p><p>D、多个 <script> 标签使用 defer 属性引入脚本时，可以确保脚本的执行是按照其被引入的顺序的</p><p><strong>所有<script>标签引进的 JavaScript 会按照他们引入的顺序依次被解析，在没有使用 defer 或者 async 的情况下，只有在解析完前面<script>元素中的代码之后，才会开始解析后面<script>元素中的代码。由于浏览器会先解析完不使用 defer 属性的<script>元素中的代码，然后再解析后面的内容，所以一般应该把<script>元素放在页面最后，即主要内容后面，</body>标签前面。</strong></p><p><strong>使用 defer 属性可以让脚本在文档完全呈现之后再执行，延迟脚本总是按照它们指定的顺序执行。</strong></p><p><strong>使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。</strong></p><p><strong>编程题</strong></p><ol start="13"><li>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</li></ol><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2</p><p>输出: [1,2]</p><p>示例 2:</p><p>输入: nums = [1], k = 1</p><p>输出: [1]</p><p>提示：</p><p>• 1 &lt;= nums.length &lt;= 105</p><p>• k 的取值范围是 [1, 数组中不相同的元素的个数]</p><p>• 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的</p><p><a href="https://zhuanlan.zhihu.com/p/402908025">小红书——前端笔试试题 - 知乎 (zhihu.com)</a></p></script></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;*红松2022年校园招聘-前端笔试*&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;*单选题*&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如下js代码会输出什么？（ A  ） C&lt;/li&gt;
&lt;/ol&gt;
&lt;figure </summary>
      
    
    
    
    
    <category term="春招" scheme="http://example.com/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/06/%E6%9C%AA%E7%9F%A5/"/>
    <id>http://example.com/2022/04/06/%E6%9C%AA%E7%9F%A5/</id>
    <published>2022-04-06T13:53:46.668Z</published>
    <updated>2022-04-07T07:37:18.323Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack</p><p>跨域</p><p>AJax原理</p><p>继承</p><p>常⻅web安全及防护原理</p><p>事件的各个阶段</p><p>怎样添加、移除、移动、复制、创建和查找节点 </p><p>正则表达式</p><p>小程序的生命周期</p><p>vue生命周期</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Webpack&lt;/p&gt;
&lt;p&gt;跨域&lt;/p&gt;
&lt;p&gt;AJax原理&lt;/p&gt;
&lt;p&gt;继承&lt;/p&gt;
&lt;p&gt;常⻅web安全及防护原理&lt;/p&gt;
&lt;p&gt;事件的各个阶段&lt;/p&gt;
&lt;p&gt;怎样添加、移除、移动、复制、创建和查找节点 &lt;/p&gt;
&lt;p&gt;正则表达式&lt;/p&gt;
&lt;p&gt;小程序的生命周期&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/31/leecode/"/>
    <id>http://example.com/2022/03/31/leecode/</id>
    <published>2022-03-31T10:04:51.124Z</published>
    <updated>2022-04-02T10:53:28.820Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>游乡里</title>
    <link href="http://example.com/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/"/>
    <id>http://example.com/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/</id>
    <published>2022-03-23T14:06:29.000Z</published>
    <updated>2022-04-11T14:51:34.760Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简单介绍一下项目"><a href="#简单介绍一下项目" class="headerlink" title="简单介绍一下项目"></a>简单介绍一下项目</h4><p>（项目意义+项目技术栈（vue轻量灵活，而且大部分对框架的要求都是vue，））</p><h4 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">-- common公用方法和样式</span><br><span class="line">  -- cloudfun.js封装数据请求</span><br><span class="line">  -- list封装公用数据比如定位，用户登录信息</span><br><span class="line">  -- util.js封装时间格式转换</span><br><span class="line">-- components 公共组件插件</span><br><span class="line">-- element组件封装</span><br><span class="line">  -- homeload</span><br><span class="line">  -- loading 加载中组件</span><br><span class="line">  -- modal模态框组件</span><br><span class="line">  -- none 没有数据提示组件</span><br><span class="line">-- node-moudle依赖包</span><br><span class="line">-- pages 页面文件</span><br><span class="line">  -- attractionDetails景点详情页面</span><br><span class="line">    -- components 组件</span><br><span class="line">      -- </span><br><span class="line">  -- catogory 景点卡片页面</span><br><span class="line">  -- city 城市定位于搜索定位</span><br><span class="line">  --index 首页</span><br><span class="line">    -- components 组件</span><br><span class="line">  -- my 个人中心</span><br><span class="line">  -- mycollect 我的收藏</span><br><span class="line">  -- search 搜索页面</span><br><span class="line">  -- store 数据仓库</span><br><span class="line">  -- strategy 游记总页面</span><br><span class="line">    -- components 组件</span><br><span class="line">      --</span><br><span class="line">  -- details 游记详情</span><br><span class="line">  -- travel 发表游记</span><br><span class="line">  </span><br><span class="line">  --static 静态文件</span><br><span class="line">    --tab 一些小图标tab啊或者分类的用到的小图标</span><br><span class="line">-- uni_moudles ?不知道这个文件是干啥的</span><br><span class="line">-- unpackage ?不知道干啥</span><br><span class="line">-- APP.vue</span><br><span class="line">--main.js</span><br><span class="line">--mainifest.json</span><br><span class="line">--package-lock.json</span><br><span class="line">-- pages.json</span><br></pre></td></tr></table></figure><h4 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h4><p>开发购物车功能</p><h5 id="第三方AI平台交互"><a href="#第三方AI平台交互" class="headerlink" title="第三方AI平台交互"></a>第三方AI平台交互</h5><p>前端（调用）云函数（使用）百度自然语言处理（使）机器处理评论返回好差评标签（上传至）云数据库（返回）评论</p><p>云函数基于node.js</p><p>aeync/await 异步编程同步化</p><h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><p>（发现问题-解决思路-解决办法）</p><p>购物车</p><p>评论：</p><p>上拉加载：</p><h5 id="搜索和搜索记录：关键字模糊查询，用的是本地存储，用户不主动删除就会永远存在的一个数据"><a href="#搜索和搜索记录：关键字模糊查询，用的是本地存储，用户不主动删除就会永远存在的一个数据" class="headerlink" title="搜索和搜索记录：关键字模糊查询，用的是本地存储，用户不主动删除就会永远存在的一个数据"></a>搜索和搜索记录：关键字模糊查询，用的是本地存储，用户不主动删除就会永远存在的一个数据</h5><h5 id="定位与搜索定位："><a href="#定位与搜索定位：" class="headerlink" title="定位与搜索定位："></a>定位与搜索定位：</h5><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327230315354.png" alt="image-20220327230315354"></p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327230613883.png" alt="image-20220327230613883"></p><h5 id="组件封装："><a href="#组件封装：" class="headerlink" title="组件封装："></a>组件封装：</h5><ol><li>（模态登录授权框）</li></ol><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327230836506.png" alt="image-20220327230836506"></p><h5 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h5><ol><li><p>云开发请求操作数据库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db=wx.cloud.database()</span><br><span class="line"><span class="keyword">const</span> banner=db.collection(<span class="string">&quot;目标数据库&quot;</span>)</span><br><span class="line">banner.get()</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>父子传值 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件中</span></span><br><span class="line">&lt;Child :data=<span class="string">&quot;data&quot;</span>&gt;&lt;/Child&gt;</span><br><span class="line"><span class="comment">//子组件中</span></span><br><span class="line">props:&#123;</span><br><span class="line">    <span class="attr">data</span>:数据类型</span><br><span class="line">&#125;</span><br><span class="line">子组件中可以直接使用data</span><br></pre></td></tr></table></figure></li><li><p>使用解构方便log操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局定义一个log</span></span><br><span class="line"><span class="keyword">var</span> &#123;log&#125;=<span class="built_in">console</span><span class="comment">//（在export代码前面）</span></span><br><span class="line"><span class="comment">//然后console.log()就可以直接用log()</span></span><br></pre></td></tr></table></figure></li><li><p>promise封装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装</span></span><br><span class="line"><span class="comment">//1.class 面向类</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.promise封装</span></span><br><span class="line"><span class="comment">//新建一个JS文件</span></span><br><span class="line"><span class="keyword">var</span> name=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> promise(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      resolve()<span class="comment">//处理正确情况，接收正确结果</span></span><br><span class="line">      reject()<span class="comment">//处理错误情况，接收错误结果</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//export &#123;name&#125;</span></span><br><span class="line"><span class="comment">//在需要用的组建中import &#123;home&#125; from  &quot;文件位置&quot; 这里的home是promise对象</span></span><br><span class="line"><span class="comment">//直接调用home().then().catch()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>并发批量请求 promise.all,该请求返回的是将里面所有请求返回的数据组合起来的一个数组</li></ol></li></ol><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220324162130697.png" alt="image-20220324162130697"></p><ol start="6"><li>使用vuex切换tab分类u</li></ol><p>uni-app自带vuex,</p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220326215110692.png" alt="image-20220326215110692"></p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220326215154071.png" alt="image-20220326215154071"></p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327222242299.png" alt="image-20220327222242299"></p><p>vuex流程图：</p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327221511195.png" alt="image-20220327221511195"></p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327221544274.png" alt="image-20220327221544274"></p><p>传递：</p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327222051907.png" alt="image-20220327222051907"></p><p>actions：实行异步操作（需要异步请求，传值到mutations），mutations实行同步操作。</p><ol start="7"><li>loading提示</li></ol><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327224049486.png" alt="image-20220327224049486"></p><p><img src="/2022/03/23/%E6%B8%B8%E4%B9%A1%E9%87%8C/image-20220327223854176.png" alt="image-20220327223854176"></p><p>页面生命周期函数只会在父组件里生效。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;简单介绍一下项目&quot;&gt;&lt;a href=&quot;#简单介绍一下项目&quot; class=&quot;headerlink&quot; title=&quot;简单介绍一下项目&quot;&gt;&lt;/a&gt;简单介绍一下项目&lt;/h4&gt;&lt;p&gt;（项目意义+项目技术栈（vue轻量灵活，而且大部分对框架的要求都是vue，））&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="项目详细" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E8%AF%A6%E7%BB%86/"/>
    
  </entry>
  
  <entry>
    <title>笔试</title>
    <link href="http://example.com/2022/03/23/%E7%AC%94%E8%AF%95/"/>
    <id>http://example.com/2022/03/23/%E7%AC%94%E8%AF%95/</id>
    <published>2022-03-23T09:38:58.000Z</published>
    <updated>2022-04-12T01:51:44.898Z</updated>
    
    <content type="html"><![CDATA[<p>webgl和three.js</p><h3 id="自如"><a href="#自如" class="headerlink" title="自如"></a>自如</h3><p>一整个无语住了，参加了自如管培生的笔试，太难了，70%的题都不会</p><p>考的基本上是数据结构，数据库，测试，操作系统</p><p>大概写一下试题：</p><ol><li>排序算法的空间复杂度与时间复杂度以及其稳定性</li><li>二叉树的前序后序中序排列</li><li>vue父子组件传值与函数调用</li><li>死锁是什么？怎么解决？怎么造成的</li><li>进程与线程？</li><li>如果aba与aab相等，abcd与acbd相等，caa与aac相等，现有两个字符串，判断她们是否相等</li><li>写一个线程安全的单例模式</li><li>如果九宫格密码，最少连接4个点，最多连接9个点，那么有多少连接方式？有多少个密码</li><li>数据库安全索引</li><li>如何测试一个产品，从哪些方面</li><li>软件缺陷提交</li><li>交换1kb的数据，三种通讯方式</li><li>Hash表</li><li>垃圾回收机制</li></ol><h3 id="创维"><a href="#创维" class="headerlink" title="创维"></a>创维</h3><ol><li><p>promise的执行,reject,resolve</p></li><li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(foo===foo)</span><br><span class="line">&#125;<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>(true +flase)&gt;2+true  打印false</p></li><li><p>JS编程范式： 命令式（简单的从上而下完成任务，流水账过程式编码风格）、面向对象（简单的从上而下完成任务，流水账过程式编码风格）、函数式</p></li><li><p>Array.apply(null,{length:1})  //返回undefied</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="built_in">Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>); </span><br><span class="line"><span class="comment">//其实直接调用Array和new Array()两种方式创建数组是一样的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.apply(&#123;<span class="attr">length</span>:<span class="number">2</span>&#125;)===<span class="built_in">Array</span>.apply([<span class="literal">undefined</span>, <span class="literal">undefined</span>])</span><br><span class="line"><span class="comment">//apply(),的第二个参数不光可以是数组还可以是个类数组对象（即包含length属性，且length属性值是个数字的对象），所有其实&#123;length：2&#125;也是一个类数组对象，只是没有进行初始化而已，取值的话返回undefined。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Array(20)：很简单，就是创建一个 length 为 20  的数组，并且JavaScript会自动为数组的每一项赋值 undefined ，而这个 undefined 和 我们自己手动赋值的undefined 有点不一样。可以理解为JavaScript自动赋上的 undefined  相当于为数组的每个值霸个位置，日后方便我们的使用（博主自己是这么理解的，有什么不对的地方，大家记得指出）。</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Array.apply(null, &#123;length: 20&#125;)：已这种方式创建出来的数组呢，数组中的每一项一创建出来就被我们赋上了确确实实的值 undefined ，而不仅仅是霸个位置那简单。如果大家以后想创建一个数组每一项一开始就是 undefined 的数组的话，那用这种方法听不错的。</span></span><br></pre></td></tr></table></figure><p><img src="/2022/03/23/%E7%AC%94%E8%AF%95/image-20220327211048695.png" alt="image-20220327211048695"></p><ol start="6"><li>for循环+setTimeout</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出三个3</span></span><br><span class="line">因为 <span class="keyword">for</span> 循环会先执行完（同步优先于异步优先于回调），这时五个 <span class="built_in">setTimeout</span> 的回调全部塞入了事件队列中，然后立即执行。</span><br><span class="line">因为 <span class="built_in">setTimeout</span> 的 <span class="built_in">console</span>.log(i); 的i是 <span class="keyword">var</span> 定义的，所以是函数级的作用域，不属于 <span class="keyword">for</span> 循环体，属于 <span class="built_in">global</span>。等到 <span class="keyword">for</span> 循环结束，i 已经等于 <span class="number">3</span> 了，因为 <span class="built_in">setTimeout</span> 的 <span class="built_in">console</span>.log(i); 的i是 <span class="keyword">var</span> 定义的，所以是函数级的作用域，不属于 <span class="keyword">for</span> 循环体，属于 <span class="built_in">global</span>。等到 <span class="keyword">for</span> 循环结束，i 已经等于 <span class="number">3</span> 了，</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回0,1,2</span></span><br><span class="line"><span class="keyword">let</span> 为代码块的作用域，所以每一次 <span class="keyword">for</span> 循环，<span class="built_in">console</span>.log(i); 都引用到 <span class="keyword">for</span> 代码块作用域下的i，因为这样被引用，所以 <span class="keyword">for</span> 循环结束后，这些作用域在 <span class="built_in">setTimeout</span> 未执行前都不会被释放</span><br></pre></td></tr></table></figure><ol start="7"><li> 文本溢出</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">overflow：hidden;</span><br><span class="line">text-overflow:ellipsis;</span><br><span class="line">white-space:nowrap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多行</span></span><br><span class="line">overflow:hidden;</span><br><span class="line">text-overflow:hidden;</span><br><span class="line">display:-webket-box;</span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>;</span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="8"><li>find(),map(),every(),some(),reduce()</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">forEach():用于调用数组的每个元素，并将元素传递给回调函数,不生成新数组,注意: forEach() 对于空数组是不会执行回调函数的。</span><br><span class="line"><span class="attr">tips</span>: forEach()中不支持使用<span class="keyword">break</span>(报错)和<span class="keyword">return</span>(不能结束循环)，有需要时可使用常规的<span class="keyword">for</span>循环。</span><br><span class="line">map(): 对所有元素执行一次函数，并生成一个由返回值组成的新数组。是否改变原数组：否 ;是否对空数组进行检测：否</span><br><span class="line">filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 是否改变原数组：否 ;是否对空数组进行检测：否</span><br><span class="line">find() 方法返回通过测试（函数内判断）的数组的**第一个**元素的值。find() 方法为数组中的每个元素都调用一次函数执行：</span><br><span class="line">    some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。some() 方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回<span class="literal">true</span> , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回<span class="literal">false</span>。</span><br><span class="line">every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。every() 方法使用指定函数检测数组中的所有元素：如果数组中检测到有一个元素不满足，则整个表达式返回 <span class="literal">false</span> ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure><ol start="9"><li> JS高阶函数</li></ol><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p><p>（array）的高阶函数主要有:</p><ol><li>map/reduce</li><li>filter</li><li>sort</li><li>every find findIndex forEach 等</li></ol><p>10</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&#x27;xxx&#x27;</span>&gt;&lt;/script&gt;</span><br><span class="line">浏览器在解析HTMl的时候，如果遇到一个人格属性的script便签，就会暂停解析，先发送网络请求获取该JS脚本的代码内容，然后让JS引擎执行改代码，当代码执行完毕后，恢复解析HTML</span><br><span class="line">&lt;script src=<span class="string">&#x27;xxx&#x27;</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br><span class="line">当浏览器遇到<span class="keyword">async</span>的，请求该脚本的网罗请求是异步的，不会阻塞浏览器解析HTML一旦网络请求回来之后，如果此时HTML还没有解析完，浏览器会暂停解析，先让JS引擎执行代码，执行完毕后再进行解析。</span><br><span class="line">&lt;script src=<span class="string">&#x27;xxx&#x27;</span> defer&gt;&lt;/script&gt;</span><br><span class="line">当浏览器遇到带有 defer 属性的 script 时，获取该脚本的网络请求也是异步的，不会阻塞浏览器解析 HTML，一旦网络请求回来之后，如果此时 HTML 还没有解析完，浏览器不会暂停解析并执行 JS 代码，而是等待 HTML 解析完毕再执行 JS 代码</span><br></pre></td></tr></table></figure><ol start="11"><li>解决跨域的方式</li></ol><p>Jsonp、cors、postMessage跨域、nginx代理跨域、nodejs中间件代理跨域、document.domain + iframe跨域、location.hash + iframe跨域、window.name + iframe跨域、WebSocket协议跨域。</p><h3 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h3><ol><li><p>关于string+number<a href="https://blog.csdn.net/m0_37122369/article/details/78066231">https://blog.csdn.net/m0_37122369/article/details/78066231</a></p></li><li><p>假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。</p></li><li><p>斐波那契数列</p></li><li><p>给定一个包含非负整数的 M x N 迷宫，请找出一条从左上角到右下角的路径，使得路径上的数字总和最小。每次只能向下或者向右移动一步。</p></li><li></li><li><p>```js<br>class A {</p><pre><code>String i = &quot;op&quot;;</code></pre><p>void func(String s) {</p><pre><code>s = &quot;&quot;+9;</code></pre><p>}<br>}<br>static void test() {</p><pre><code>A a = new A();a.func(a.i);</code></pre><p>}</p><ol><li>i,s,a都在栈中，new出来的对象A在堆上。字符串变量i,s以及对象指针a都存在栈中，new出来的对象开辟内存存在堆上，对应地址是指针a存的内容</li><li>执行完后a.i的值还是字符串op。a.func(a.i)这句执行函数，把a.i作为参数传递，该函数会复制一个变量，两个变量完全独立，所以在函数体里只是把复制的那个变量（一个新的局部变量）改变为’op9’,在函数体外的a.i并没有被改变</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">8. </span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   // 定时器任务属于宏任务，并且需要先在任务队列等待，等到同步任务执行完，执行栈清空，才会在任务队列中按顺序选任务进去</span><br><span class="line">   setTimeout(() =&gt; console. log ( &#x27;a&#x27; )); //4. 打印a</span><br><span class="line">   //Promise 属于异步微任务，在本轮同步任务结束之前执行</span><br><span class="line">   Promise.resolve().then(</span><br><span class="line">       // 1. 打印 b</span><br><span class="line">       () =&gt; console. log ( &#x27;b&#x27; )  // 单引号要改为&#x27;,然后去掉;号</span><br><span class="line">   ).then(</span><br><span class="line">       // 箭头函数的resolve传递的参数作为下一个then的参数</span><br><span class="line">       () =&gt; Promise.resolve( &#x27;c&#x27; ).then(</span><br><span class="line">           // 执行箭头函数</span><br><span class="line">           (data) =&gt; &#123;</span><br><span class="line">               // 把定时器任务也放入任务队列中等待，在第一个定时器之后</span><br><span class="line">               setTimeout(() =&gt; console. log ( &#x27;d&#x27; )); //5. 打印d</span><br><span class="line">               // 2.打印 f</span><br><span class="line">               console. log ( &#x27;f&#x27; );</span><br><span class="line">               // 此时返回的 数据作为下一个then的参数</span><br><span class="line">               return data;</span><br><span class="line">           &#125;</span><br><span class="line">       )</span><br><span class="line">   ).then(data =&gt; console. log (data));  // 3.打印 c</span><br><span class="line">   //打印bfcad </span><br></pre></td></tr></table></figure><ol start="9"><li></li><li></li></ol><p><img src="/2022/03/23/%E7%AC%94%E8%AF%95/image-20220323220059462.png" alt="image-20220323220059462"></p><p><img src="/2022/03/23/%E7%AC%94%E8%AF%95/image-20220323220119915.png" alt="image-20220323220119915"></p></li></ol><h3 id="有米科技笔试"><a href="#有米科技笔试" class="headerlink" title="有米科技笔试"></a>有米科技笔试</h3><ol><li>数组扁平化</li></ol><p>用于将嵌套的数组”拉平“，变成一维的数组，该方法返回一个新数组，对原数据没有影响</p><p>思路：在数组中找到是数组类型的元素，然后将其展开。</p><ul><li>第一步：遍历数组</li></ul><p>​        方法：for循环、for…of，for…in，foreach()、entries（）、keys（）、values（）、reduce（）、[ map() ] ( )</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]], <span class="number">5</span>, <span class="string">&quot;string&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;弹铁蛋同学&quot;</span> &#125;];</span><br><span class="line"><span class="comment">// 遍历数组的方法有太多，本文只枚举常用的几种</span></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for...in</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// forEach 循环</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// entries（）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, value] <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reduce()</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(cur);</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line">arr.map(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value));</span><br></pre></td></tr></table></figure><ul><li><p>判断元素是数组的方式</p><p>instanceof </p><p>constructor</p><p>Object.prototype.toString</p><p>idArray</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>)</span><br><span class="line"><span class="keyword">if</span>(arr.conatructor===<span class="built_in">Array</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.soString.call(arr)===<span class="string">&#x27;[object Array]&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(arr))<span class="comment">//最好</span></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure></li><li><p>将数组的元素展开一层的方案</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">扩展运算符 + `concat`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat` +`apply</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展运算符 + concat</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]], <span class="number">5</span>, <span class="string">&quot;string&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;弹铁蛋同学&quot;</span> &#125;];</span><br><span class="line">[].concat(…arr)<span class="comment">//contact（）用于合并两个或多个数组</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// concat + apply，利用apply在绑定作用于时，传入的第二个参数是一个数组或者类数组对象，其中的数组元素将作为单独的参数穿给func函数。也就是在调用apply函数的过程中，会将传入的数组一个一个的传入打要执行的函数中，也就是相当于对数组进行了一层的展开。</span></span><br><span class="line">[].concat.apply([], arr);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, &quot;string&quot;, &#123; name: &quot;弹铁蛋同学&quot; &#125;];</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 =[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]]]</span><br><span class="line">arr2.toString().split(<span class="string">&#x27;,&#x27;</span>).map(<span class="function"><span class="params">v</span>=&gt;</span><span class="built_in">parseInt</span>(v))</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3]</span></span><br><span class="line"><span class="comment">//不推荐使用 toString + split 方法，因为操作字符串是和危险的事情，在上一文章中我做了一个操作字符串的案例还被许多小伙伴们批评了。如果数组中的元素所有都是数字的话，toString +split 是可行的，并且是一步搞定。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//总结如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span> (<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr2=[]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">            arr2=arr2.concat(flat(value))  </span><br><span class="line">            <span class="comment">//arr2 = arr2.concat(...value)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            arr2.push(item)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>ES6操作数组的新方法</li></ol><p><a href="http://www.codebaoku.com/it-js/it-js-242621.html">关于ES6中数组新增的方法详解 - 编程宝库 (codebaoku.com)</a></p><ul><li>Array,find(（item,index）=&gt;{}) 参数为回调函数，对所有元素执行该回调函数，返回第一个为true的成员，如果没有符合的则返回undefined</li><li>Array,findindex(（item,index）=&gt;{}) 同上，但是返回的是元素位置下标，如果没有则返回-1</li><li>Array.flat()用于拉平嵌套的数组</li><li>Array.at()返回数组对应下标的值，支持负索引，如果参数位置超出了数组范围，at()返回undefined。</li><li>Array.from()一个类似数组的对象，将他转换成真正的数组，需要注意的是:这个类似数组的对象必须要有length属性才可以，转为数组。否者将会转为为一个空数组</li><li>Array.includes()，返回布尔值，表示数组中是否包含给定的值</li></ul><p>在有includes之前，使用indexOf进行判断，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arr.indexOf(el)!==-<span class="number">1</span>)&#123;<span class="comment">//有这个值&#125;</span></span><br></pre></td></tr></table></figure><ul><li>扩展运算符</li></ul><p>将一个数组转为用逗号分隔的参数序列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">es5的合并</span><br><span class="line">arr=arr1.concat(arr2)</span><br><span class="line">es6的合并</span><br><span class="line">arr=[...arr1,...arr2]</span><br></pre></td></tr></table></figure><ol start="3"><li>浏览器的强缓存和协商缓存</li></ol><p>浏览器缓存（Brower Caching）是浏览器对之前请求过的文件进行缓存，以便下一次访问时重复使用，节省带宽，提高访问速度，降低服务器压力。</p><p><strong>强缓存</strong>：浏览器不会向服务器发送任何请求，直接从本地缓存中，读取文件并返回Status Code 200 OK</p><p><img src="/2022/03/23/%E7%AC%94%E8%AF%95/image-20220330165535420.png" alt="image-20220330165535420"></p><p>from memory cache:不访问服务器，一般已经加载过该资源且缓存在了内存中，直接从内存中读取缓存，浏览器关闭后，数据将不再出现，再次打开相同的页面不会出现from memory cache。</p><p>from disk cache:不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉，下次打开还是from disk cache</p><p>优先访问memory cache,其次是disk cache，最后是请求网络资源</p><p><strong>协商缓存</strong>：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是命中协商缓存，如果命中，则返回304状态码并带上新的rsponse header 通知浏览器从缓存中读取资源。</p><p><img src="/2022/03/23/%E7%AC%94%E8%AF%95/image-20220330171125055.png" alt="image-20220330171125055"></p><p><a href="https://juejin.cn/post/6844903838768431118">https://juejin.cn/post/6844903838768431118</a></p><ol start="3"><li>ES 6的模块机制与CommonJS的模块化</li></ol><p>模块化：将独立的功能代码封装成一个独立的文件，其他模块需要使用，再进行引用。</p><p>模块化有利于代码的拆分和架构上的解耦。</p><p><strong>commonJS</strong></p><p>commonJs规范应用与nodeJS应用中，在node中每一个文件就是一个模块，拥有自己作用域，文件中的变量、函数都是私有的，与其他文件相隔离。</p><p>ES6模块化</p><p>使用export导出，import导入</p><p><strong>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong></p><p>运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</p><p>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</p><ol start="4"><li>nodeJS是单线程</li></ol><p>采用单线程异步非阻塞模式。Node.js采用事件驱动和异步I/O的方式，实现了一个单线程、<a href="https://so.csdn.net/so/search?q=%E9%AB%98%E5%B9%B6%E5%8F%91&spm=1001.2101.3001.7020">高并发</a>的运行时环境，而单线程就意味着同一时间只能做一件事。</p><ol start="5"><li>浏览器的事件循环机制</li></ol><p>JS是一门单线程的语言，同一时间就只能做一件事情，所以，为了实现单线程任务不阻塞的方法就是事件循环。js的任务有两种，同步任务和异步任务，同步任务就是立即执行的任务，异步任务就是异步执行的任务，比如ajax请求，setTimout定时函数。任务进入到执行栈之后，就会判断他是同步任务还是异步任务，如果是同步任务，就会进入到主线程里面，如果是异步任务就会进入到任务队列里面，主线程里面的同步任务执行为空，就会去任务列队读取对应的异步任务，再推入到主线程执行。这个过程的不断重复就是事件循环。</p><p>这里面关于异步任务的执行，还可以细分为微任务和宏任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏任务</span></span><br><span class="line">script(整体代码)</span><br><span class="line"><span class="built_in">setTimeout</span></span><br><span class="line"><span class="built_in">setInterval</span></span><br><span class="line">I/O</span><br><span class="line">UI交互事件</span><br><span class="line">postMessage</span><br><span class="line">MessageChannel</span><br><span class="line">setImmediate(Node.js 环境)</span><br><span class="line"><span class="comment">//微任务</span></span><br><span class="line"><span class="built_in">Promise</span>.then</span><br><span class="line"><span class="built_in">Object</span>.observe</span><br><span class="line">MutationObserver</span><br><span class="line">process.nextTick(Node.js 环境)</span><br></pre></td></tr></table></figure><ol start="6"><li>set、map、weakset和weakmap</li></ol><p>Set</p><ol><li><p>成员不能重复</p></li><li><p>只有健值，没有健名，有点类似数组。</p></li><li><p>可以遍历，方法有add, delete,has</p></li></ol><p>weakSet</p><ol><li>成员都是对象</li><li>成员都是弱引用，随时可以消失。 可以用来保存DOM节点，不容易造成内存泄漏</li><li>不能遍历，方法有add, delete,has</li></ol><p>Map</p><ol><li>本质上是健值对的集合，类似集合</li><li>可以遍历，方法很多，可以跟各种数据格式转换</li></ol><p>weakMap</p><ol><li>直接受对象作为健名（null除外），不接受其他类型的值作为健名</li><li>健名所指向的对象，不计入垃圾回收机制</li><li>不能遍历，方法同get,set,has,delete</li></ol><h3 id="多益笔试"><a href="#多益笔试" class="headerlink" title="多益笔试"></a>多益笔试</h3><ol><li>symbol </li></ol><p>ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</p><p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。</p><p>由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sy = <span class="built_in">Symbol</span>(<span class="string">&quot;KK&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sy);   <span class="comment">// Symbol(KK)</span></span><br><span class="line"><span class="keyword">typeof</span>(sy);        <span class="comment">// &quot;symbol&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 相同参数 Symbol() 返回的值不相等</span></span><br><span class="line"><span class="keyword">let</span> sy1 = <span class="built_in">Symbol</span>(<span class="string">&quot;kk&quot;</span>); </span><br><span class="line">sy === sy1;       <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>js</code>引擎执行<code>0.1+0.2==0.3</code>返回<code>false</code>，为什么？请给出解决办法</li></ol><p>在JavaScript中，<code>0.1 + 0.2 = 0.3000000000000000444089209850062616169452667236328125000000000000</code>，<code>0.1 + 0.2 - 0.3 = 5.551115123125783e-17</code></p><p>造成这个问题主要是因为十进制与二进制在转换中出现精度问题</p><ol start="3"><li><p>实现一个单选框</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单选框</span></span><br><span class="line">&lt;label&gt; <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">vlaue</span>=<span class="string">&quot;男生&quot;</span>&gt;</span>男生<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="comment">//多选框</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;like&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>选项1<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>斐波那契编程</p></li><li><p>单链表后插入一个节点</p></li><li><p>写一个正则表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 去掉空格</span></span><br><span class="line"> /(^\s+)|(\s+$)/g</span><br><span class="line"><span class="comment">//2. 所有空格</span></span><br><span class="line"> /\s*/g</span><br><span class="line"><span class="comment">//3. 乱写一个 第一个数字00不为0的</span></span><br><span class="line"> /[<span class="number">1</span>-<span class="number">9</span>].+\s*/</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>立即执行函数</p></li><li><p>轮询长轮询，websoket</p></li><li><p>readonly和disabled</p></li><li><p>new操作符的作用</p><p>通过构造函数来创建一个实例对象。</p><p>创建原型链</p><p>改变构造函数的this指向</p><p>会对构造函数的返回值做一些判断</p></li><li><p>dispaly，visibility,opcity的重绘重排</p></li><li><p>bundler</p></li><li><p>在数组指定位置插入元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">操作字符串的方法和操作数组的方法</span><br><span class="line">字符串：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数组：</span><br><span class="line">push()尾部添加 pop()尾部删除</span><br><span class="line">unshift()头部添加 shift()头部删除</span><br><span class="line"></span><br><span class="line"><span class="comment">//在数组指定位置插入</span></span><br><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line">fruits.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;Lemon&quot;</span>, <span class="string">&quot;Kiwi&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Banana, Orange, Lemon, Kiwi, Apple, Mango</span></span><br><span class="line">index    必需。规定从何处添加/删除元素。</span><br><span class="line">该参数是开始插入和（或）删除的数组元素的下标，必须是数字。</span><br><span class="line">howmany    必需。规定应该删除多少元素。必须是数字，但可以是 <span class="string">&quot;0&quot;</span>。如果未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</span><br><span class="line">item1, ..., itemX    可选。要添加到数组的新元素</span><br><span class="line">返回值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>+“1e”=parseInt(“1e”)   不理解这个题是什么意思，但是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt：解析一个字符串并返回指定基数的十进制整数（默认）</span><br></pre></td></tr></table></figure></li><li><p>rem与em的区别</p></li><li></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;!DOCTYPE&gt; 声明不是 HTML 标签；</span></span><br><span class="line"><span class="comment">它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令</span></span><br><span class="line"><span class="comment">。以上是H5声明的方式在更老的文档中 声明必须引用 DTD (Document Type Definition)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 元素语言的定义 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 规定 HTML 文档的字符编码： --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="17"><li>script标签的位置以及属性</li></ol><ul><li>放在<head>标签内部时，浏览器解析HTML标签，发现script标签时，会先下载完所有的script，再往下解析其他的HTML。——容易出现滞后</head></li><li>放在<body>外部 不标准</body></li><li>放在body内部 对于高度依赖JS的页面加载缓慢 </li></ul><h3 id="ZUvi原里笔试"><a href="#ZUvi原里笔试" class="headerlink" title="ZUvi原里笔试"></a>ZUvi原里笔试</h3><p>只有45分钟，时间过得的太快了有点忘了</p><ol><li>写出5重加快H5加载的方法</li></ol><p><a href="https://www.pkak.cn/wt/7296.html">https://www.pkak.cn/wt/7296.html</a></p><ol><li>循环链表插入的方法</li><li>dispaly的重绘重排</li><li>输入一个数组和一个数，找到这个数组中相加等于这个数的，输出他们三个，如果同时有多对，那么输出成绩最小的。</li><li>CSS样式权重</li></ol><p><img src="/2022/03/23/%E7%AC%94%E8%AF%95/image-20220331210803264.png" alt="image-20220331210803264"></p><h3 id="赛意信息"><a href="#赛意信息" class="headerlink" title="赛意信息"></a>赛意信息</h3><ol><li>vue中每个data使用function (){return }是为了</li><li>CSS样式权重</li><li>不属于数组的方法</li><li>块级标签，display的值</li></ol><p>list-item,table,none,block,inline-block,table-cell,inherit</p><ol start="5"><li>为什么使用DIV+CSS布局</li></ol><p>div+css页面增加网页打开速度</p><p>重构页面修改方便</p><p>divcss有利于搜索引擎爬虫</p><h3 id="其他模拟笔试"><a href="#其他模拟笔试" class="headerlink" title="其他模拟笔试"></a>其他模拟笔试</h3><ol><li><p>已知，1000个硬币里有10个金币。随机的取出n个硬币，则取出硬币里有金币的概率是多少？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">思路：如果n&gt;<span class="number">990</span>，则一定会取到金币</span><br></pre></td></tr></table></figure></li><li><p>当padding/margin为百分比时，无论-top/-bottom还是left/right，对应的都是父类的width</p></li><li><p>1.匹配相关：与正则表达式配合使用</p><p>（1）str.match(RegExp):匹配指定字符串</p><p>（2）str.replace(RegExp):替换指定字符</p><p>（3）str.search(RegExp):查找字符</p><p>2.索引相关：</p><p>（1）charAt(index):通过索引值查找，返回指定字符</p><p>（2）indexOf(val):返回指定字符首次出现的位置</p><p>（3）lastIndexOf(val):返回指定字符最后出现的位置</p><p>（4）charCodeAt(index):返回指定字符的Unicode编码，介于0 - 65535的数字</p><p>3.操作字符相关：</p><p>（1）str1.concat(str2,…,strn) :连接字符串</p><p>（2）str.slice(start,end):传入两个索引值，截取两个值之间的字符串，不包括end值。返回新字符串。若start为负数，从最后一位开始数起。</p><p>（3）str.substr(start,length):传入截取的其实索引值和截取的长度，返回新字符串，若start为负数，从最后一位开始数起。</p><p>（4）str.substring(from,to):传入两个索引值，截取两个值之间的字符串，不包括to值。返回新字符串，若start为负数，默认start为0.</p><p>（5）str.split(spearator,limit):分割字符串，以数组形式返回。spearator指定切割的地方，limit设置返回字符串的最大长度.用于指定字符<strong>两边</strong>分割字符串，分割后的元素（包括空白符）依次放入[ ]得到一个数组。</p><p>4.不需要传参：</p><p>（1）str.valueOf():返回字符串原始值</p><p>（2）str.toUpperCase():字符串大写</p><p>（3）str.toLowerCase():字符串小写</p><p>（4）str.trim():去掉字符串两边空白</p></li></ol><p>操作数组：</p><p>arr.shift（）从数组头部删除一个元素，返回删除的元素，改变原数组</p><p>arr.push()在数组尾部添加一个元素，改变原数组。</p><ol start="4"><li><p>信号量分为<strong>互斥量</strong>和<strong>信号量</strong>互斥量的初始值一般为1，表示临界区只允许一个进程进入**，从而实现互斥；</p><p><strong>互斥量等于0</strong>时，表示<strong>临界区已经有1个进程进入</strong>，<strong>临界区外无进程等待</strong>；</p><p><strong>互斥量小于0</strong>时，表示<strong>临界区****已经有1个进程进入</strong>，<strong>互斥量的绝对值表示在临界区外等待进入的进程数</strong>。</p><p>资源信号量的初值可以是任意整数，<strong>表示可用的资源数</strong>，<strong>资源数小于0时，表示所有资源全部用完</strong>，<strong>而且还有进程正在等待使用该资源</strong>，<strong>等待的进程数就是资源量的绝对值。</strong></p></li><li><p>颜色代码可以用#RRGGBB[AA]表示，R表示红，G表示绿，B表示蓝，A是透明度，透明度可以省略，默认是FF。</p><p>除了这种完整版，还有一种缩减版，用#RGB[A]表示，#f098相当于#ff009988。</p><p>这两种使用的都是16进制编码，所以只会出现0-9a-f。</p></li><li><p>正则表达式</p></li><li><p>JSON.parse与JSON.stringfy</p></li><li><p>strcpy   没限制长度可能导致溢出（安全版本strncpy）</p><p> strncat  限制了copy的长度就没问题，strcat可能导致溢出</p><p> sprintf   和printf()一样，有格式化字符串攻击的可能</p><p> strcmp  比较两个string长度，无危害</p></li><li></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].slice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line"><span class="comment">//输出什么？</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>]和[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//为什么</span></span><br><span class="line"><span class="attr">splice</span> :删除数组中制定位置的元素并返回该元素，第三个参数至后面所有参数表示从删除元素的位置开始插入这些参数。该方法会改变原数组。</span><br><span class="line">所以[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)的意思是，从序号<span class="number">1</span>开始删除<span class="number">2</span>个元素，并且将<span class="number">3.4</span><span class="number">.5</span>插入序号<span class="number">1</span>的位置，返回[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="attr">slice</span>:只有两个参数</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_30500105/article/details/101064944012">https://blog.csdn.net/weixin_30500105/article/details/101064944012</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webgl和three.js&lt;/p&gt;
&lt;h3 id=&quot;自如&quot;&gt;&lt;a href=&quot;#自如&quot; class=&quot;headerlink&quot; title=&quot;自如&quot;&gt;&lt;/a&gt;自如&lt;/h3&gt;&lt;p&gt;一整个无语住了，参加了自如管培生的笔试，太难了，70%的题都不会&lt;/p&gt;
&lt;p&gt;考的基本上是数据</summary>
      
    
    
    
    
    <category term="春招" scheme="http://example.com/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/03/23/%E4%B9%A6%E7%B1%8D/"/>
    <id>http://example.com/2022/03/23/%E4%B9%A6%E7%B1%8D/</id>
    <published>2022-03-23T07:30:51.418Z</published>
    <updated>2022-03-24T02:44:59.117Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2022/03/23/%E4%B9%A6%E7%B1%8D/image-20220323153105198.png" alt="image-20220323153105198"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2022/03/23/%E4%B9%A6%E7%B1%8D/image-20220323153105198.png&quot; alt=&quot;image-20220323153105198&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>题</title>
    <link href="http://example.com/2022/03/22/%E9%A2%98/"/>
    <id>http://example.com/2022/03/22/%E9%A2%98/</id>
    <published>2022-03-22T01:23:52.000Z</published>
    <updated>2022-04-11T13:48:14.377Z</updated>
    
    <content type="html"><![CDATA[<h5 id="预编译习题"><a href="#预编译习题" class="headerlink" title="预编译习题"></a>预编译习题</h5><p><strong>预编译</strong>：作用域的创建阶段</p><p>JS的变量对象 AO对象 供JS引擎自己去访问的</p><ol><li>创建了AO对象</li><li>找形参和变量的声明 作为AO对象的属性名 值是Undefined</li><li>实参和形参相统一</li><li>找函数声明 会覆盖变量的声明</li></ol><p><img src="/2022/03/22/%E9%A2%98/image-20220322095349970.png" alt="image-20220322095349970"></p><p>预编译阶段执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AO：&#123;</span><br><span class="line">a：undefined  1  function a()&#123;&#125;</span><br><span class="line">c：undefined  2  function c()&#123;&#125;</span><br><span class="line">d：undefined </span><br><span class="line">b：undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JS的逐行执行</strong></p><p><img src="/2022/03/22/%E9%A2%98/image-20220322095316739.png" alt="image-20220322095316739"></p><h5 id="this"><a href="#this" class="headerlink" title="this"></a>this</h5><p>this使用：</p><ol><li><p>在函数中直接使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line">get(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line"><span class="comment">//get.call(window,&quot;你好&quot;) 两者相同</span></span><br></pre></td></tr></table></figure></li><li><p>函数作为对象的方法被调用（谁调用我，我就指向谁）</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">run</span>:<span class="function"><span class="keyword">function</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>最多$&#123;time&#125;min就不行了)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">person.run(<span class="number">30</span>)</span><br><span class="line"><span class="comment">//person.run.call(person,30)</span></span><br></pre></td></tr></table></figure><p><strong>习题</strong></p><p><img src="/2022/03/22/%E9%A2%98/image-20220322103330154.png" alt="image-20220322103330154"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun.call(<span class="built_in">window</span>)  <span class="number">222</span></span><br><span class="line">a.say.call(a)  <span class="number">111</span></span><br><span class="line">b.say.call(b,a.say) <span class="number">222</span></span><br><span class="line">b.say.call(b) <span class="number">333</span></span><br></pre></td></tr></table></figure><h6 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h6><p>箭头函数中的this是定义函数时绑定的，而不是执行的时候绑定的。箭头函数没有自己的this，导致内部的this就是外部代码块的this。箭头函数不能用作构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    x=<span class="number">22</span>,</span><br><span class="line">    <span class="attr">say</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()<span class="comment">//11</span></span><br></pre></td></tr></table></figure><p>所谓的定义时候绑定，就是this是继承自父执行上下文中的this，比如这里箭头函数与say平级，也就是说箭头函数本身所在的对象是obj，那么他的父执行上下文就是window</p><p><img src="/2022/03/22/%E9%A2%98/image-20220322105138687.png" alt="image-20220322105138687"></p><h5 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h5><h5 id="js的作用域"><a href="#js的作用域" class="headerlink" title="js的作用域"></a>js的作用域</h5><h6 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h6><ul><li>全局作用域在页面打开时被创建，页面关闭时被销毁</li><li>编写在script标签中的变量和函数，作用域为全局，在页面的任意位置都可以访问到</li><li>在全局作用域中有全局对象window，代表一个浏览器窗口，由浏览器创建，可以直接调用</li><li>全局作用域中声明的变量和函数会作为window对象的属性和方法保存</li></ul><h6 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h6><ul><li>调用函数时，函数作用域被创建，函数执行完毕，函数作用域被销毁</li><li>每调用一次函数就会创建一个新的函数作用域，他们之间相互独立</li><li>在函数作用域中可以访问到全局作用域的变量，在函数外无法访问到函数作用域内的变量</li><li>在函数作用域中访问变量、函数时，会先在自身作用域中寻找，若没有找到，则回到函数的上一级作用域中寻找，一直到全局作用域。</li></ul><h6 id="块级作用域-JS本身没有块级作用域，但是在ES6之后可以模仿块级作用域"><a href="#块级作用域-JS本身没有块级作用域，但是在ES6之后可以模仿块级作用域" class="headerlink" title="块级作用域(JS本身没有块级作用域，但是在ES6之后可以模仿块级作用域)"></a>块级作用域(JS本身没有块级作用域，但是在ES6之后可以模仿块级作用域)</h6><h6 id="作用域的深层次理解"><a href="#作用域的深层次理解" class="headerlink" title="作用域的深层次理解"></a>作用域的深层次理解</h6><p><strong>执行上下文</strong></p><p>当函数在代码执行的前期，会创建一个执行器上下文的内部对象 AO  （作用域），这个内部的独享是预编译的时候创建出来的，因为当函数被调用的时候，会先进项预编译；在全局代码执行的亲戚会创建一个执行上下文的对象 GO</p><p><strong>函数作用域编译</strong></p><ol><li>创建AO对象</li><li>找形参和变量的声明 作为AO对象的属性名 值是Undefined</li><li>实参和形参相统一</li><li>找函数声明 会覆盖变量的声明</li></ol><p><strong>全局作用域编译</strong></p><ol><li>创建GO 对象</li><li>找变量声明 将变量名作为GO对象的属性名 值是 undefined</li><li>找函数声明 值赋予函数体</li></ol><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>会被保存到一个隐式的属性中去[[scope]]，这个属性是我们用户访问不到的，但是的的确确是存在的，让JS引擎来访问的，里面存储的就是作用域链</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">global</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bb=<span class="number">123</span></span><br><span class="line">        aa=<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> aa=<span class="number">234</span></span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/%E9%A2%98/image-20220322153134105.png" alt="image-20220322153134105"></p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>一个函数引用另一个函数作用域中的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">123</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bb=<span class="number">123</span></span><br><span class="line">        <span class="built_in">console</span>.log(aa)</span><br><span class="line">    &#125;</span><br><span class="line">    retuen b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> res=a()<span class="comment">//得到的是b函数，将b函数暴露在a函数外部</span></span><br><span class="line">res()</span><br></pre></td></tr></table></figure><p>JS的单例模式（没看懂）</p><p><img src="/2022/03/22/%E9%A2%98/image-20220322163250278.png" alt="image-20220322163250278"></p><h5 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h5><p><strong>当持续促发事件（键盘持续输入内容）  一定时间内没有再触发事件（一定时间内没有再输入）  事件处理函数才会执行一次 如果设定的事件到来之前 又一次触发了函数 就重新开始计时</strong></p><p>比如一个定了一定时间的定时器，在这个定时器时间定完后才会执行事件函数，如果中途点击了这个定时器，那么时间就会重新计时，等重新计时完成才会执行时间函数(就像王者荣耀回城一样，只有在不被别人打断n秒后才能回去， 否则这期间有人打断就会重新计时。)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">functon <span class="function"><span class="title">debounce1</span>(<span class="params">delay,value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="comment">//既然在计时之时再次输入内容，不能打印东西，那么就要清除以前触发的定时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer) <span class="comment">//错误  这里的timer是undefined 要使timer一直在内存中-&gt; 内存泄露 -&gt;闭包</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value)</span><br><span class="line">    &#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我需要的是输入框的结果只出现一次，是在我键盘抬起不在输入后的1秒之后</span></span><br><span class="line">input.addEventLinstener(<span class="string">&quot;keyup&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    debounce(<span class="number">1000</span>,e,target.value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">functon <span class="function"><span class="title">debounce2</span>(<span class="params">delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer</span><br><span class="line">    <span class="comment">//匿名函数实现闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">value</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer) </span><br><span class="line">        timer=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(value)</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> deFUnc=debounce2(<span class="number">1000</span>)</span><br><span class="line">input.addEventLinstener(<span class="string">&quot;keyup&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    deFUnc(e,target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用条件: 1,如果客户连续的操作会导致频繁的事件回调(可能引起页面卡顿). 2,客户只关心”<strong>最后一次</strong>“操作(也可以理解为停止连续操作后)所返回的结果. 例如:</p><ul><li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li><li>不断的调整浏览器窗口大小会不断的触发resize事件，用防抖来让其只触发一次。</li><li>按钮点击:收藏,点赞,心标等</li></ul><h5 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h5><p><strong>当持续触发事件的时候 保证一段时间内 只调用一次事件处理函数 一段时间内 只做一件事情</strong></p><p>在一定时间之内，限制一个动作只执行一次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thro</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timerOut</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!timerOut)&#123;</span><br><span class="line">            timerOut=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func()<span class="comment">//事件处理函数</span></span><br><span class="line">                timerOut=<span class="literal">null</span></span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">//需要的是哪怕是1秒内点击了100次，也只执行一次</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&quot;button&quot;</span>).onclick=thro(func ,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><h5 id="setTimeOut与setInterval"><a href="#setTimeOut与setInterval" class="headerlink" title="setTimeOut与setInterval"></a>setTimeOut与setInterval</h5><p>用setTimerout实现setInterval</p><h5 id="JS的事件循环机制"><a href="#JS的事件循环机制" class="headerlink" title="JS的事件循环机制"></a>JS的事件循环机制</h5><p>虽然浏览器是单线程执行js代码的，但是浏览器世纪是以多个线程协助操作来实现单线程异步模型的，具体线程组成如下：</p><ol><li>GUI渲染线程</li><li>JS引擎线程</li><li>定时器触发线程</li><li>HTTP请求线程</li><li>其他线程</li></ol><p><strong>在JavaScript代码运⾏的过程中实际执⾏程序时同时只存在⼀个活动线程，这⾥实现同步异步就是靠</strong>多线程切换的形式来进⾏实现的。</p><p>所以我们通常分析时，将上⾯的细分线程归纳为下列两条线程：</p><ol><li><p>【主线程】：这个线程⽤了执⾏⻚⾯的渲染，JavaScript代码的运⾏，事件的触发等等</p></li><li><p>【⼯作线程】：这个线程是在幕后⼯作的，⽤来处理异步任务的执⾏来实现⾮阻塞的运⾏模式</p></li></ol><p><strong>微任务是由ES6语法规定的，宏任务是由浏览器规定的</strong></p><p>例题：</p><ol><li><p><img src="/2022/03/22/%E9%A2%98/image-20220322204849637.png" alt="image-20220322204849637"></p></li><li><p><img src="/2022/03/22/%E9%A2%98/image-20220322195834164.png" alt="image-20220322195834164"></p></li></ol><p><img src="/2022/03/22/%E9%A2%98/image-20220322201900256.png" alt="image-20220322201900256"></p><ol start="3"><li>```JS<br>setTimeout(function() {console.log(‘timer1’)}, 0)<br>setTimeout(function() {console.log(‘timer2’)}, 0)<br>new Promise(function executor(resolve) {<pre><code>console.log(&#39;promise 1&#39;)resolve()console.log(&#39;promise 2&#39;)</code></pre>}).then(function() {<pre><code>console.log(&#39;promise then&#39;)</code></pre>})<br>console.log(‘end’)<br>输出： promise1 promise2 end promise then timer1 timer2<br>注意：<br>按照同步先⾏，异步靠后的原则，阅读代码时，先分析同步代码和异步代码，Promise对象虽然是微任务，但是<br>new Promise时的回调函数是同步执⾏的，所以优先输出promise 1 和 promise 2。 在resolve执⾏时Promise对象的状态变更为已完成，所以then函数的回调被注册到微任务事件中，此时并不执<br>⾏，所以接下来应该输出end。<br>同步代码执⾏结束后，观察异步代码的宏任务和微任务，在本次的同步代码块中注册的微任务会优先执⾏，参考上<br>⽂中描述的列表，Promise为微任务，setTimeout和requestAnimationFrame为宏任务，所以Promise的异步任务<br>会在下⼀个宏任务执⾏前执⾏，所以promise then是第四个输出的结果。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">##### 深浅拷贝与赋值</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">var num=123</span><br><span class="line">var person=&#123;</span><br><span class="line">    name:&#x27;乔丹&#x27;,</span><br><span class="line">    likes:&#123;</span><br><span class="line">        a:1,</span><br><span class="line">        b:&#123;</span><br><span class="line">            c:2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//赋值：</span><br><span class="line">var person1=person</span><br><span class="line">person1.name=&#x27;科比&#x27;</span><br><span class="line">console.log(person.name) //科比</span><br><span class="line">console.log(person1.name)//科比</span><br><span class="line">//浅拷贝：1.创建一个新的对象 2.拷贝值(如果属性是一般数据类型 拷贝的就是基本类型的值 如果属性是引用数据类型那么拷贝的就是内存的地址)</span><br><span class="line">function shallowClone(source)&#123;</span><br><span class="line">    var newObj=&#123;&#125;</span><br><span class="line">    for(var i in source)&#123;</span><br><span class="line">        newonj[i]=source[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return newobj</span><br><span class="line">&#125;</span><br><span class="line">console.log(person.name)//乔丹</span><br><span class="line">console.log(person1.name)//科比</span><br><span class="line">//es6 for……of版</span><br><span class="line">for(var [key,value] of Object.entires(source))&#123;</span><br><span class="line">    newonj[key]=value</span><br><span class="line">&#125;</span><br><span class="line">//解构版浅拷贝</span><br><span class="line">var target = &#123; ...obj &#125;</span><br><span class="line">target.goods[0] = &#x27;天才&#x27;</span><br><span class="line">console.log(obj.goods[0])</span><br><span class="line">//深拷贝：如果属性是引用数据类型那么就会开辟一个新堆，在浅拷贝的基础之上</span><br><span class="line">//第一种JSON.parse</span><br><span class="line">let arr = [1, 3, &#123;</span><br><span class="line">    username: &#x27; kobe&#x27;</span><br><span class="line">&#125;];</span><br><span class="line">let arr4 = JSON.parse(JSON.stringify(arr));</span><br><span class="line">//第二种是内存的地址)</span><br><span class="line">function deppClone(source)&#123;</span><br><span class="line">    var newObj=&#123;&#125;</span><br><span class="line">    for(var i in source)&#123;</span><br><span class="line">        if(typoof obj[i]===&quot;object&quot;||obj[i]!==null)//判断是否是对象</span><br><span class="line">        &#123;</span><br><span class="line">            newObj[i]=&#123;&#125;</span><br><span class="line">            for (var j in obj[j])&#123;</span><br><span class="line">                newObj[i][j]=obj[i][j]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            newonj[i]=source[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    return newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="实现轮播图的"><a href="#实现轮播图的" class="headerlink" title="实现轮播图的"></a>实现轮播图的</h5><p><a href="https://blog.csdn.net/qq_20495901/article/details/122936580">JS实现轮播图（一看就懂逻辑清晰）_Beannnnnnn的博客-CSDN博客_js无缝轮播图实现原理</a></p><h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try catch finally"></a>try catch finally</h5><p>try 块里一共有三个关键字try catch 和finally</p><p>,finally语句无论try和catch执行结果如如何都会执行，catch时捕获到try语句里的错误才会执行。 catch 和 finally 语句都是可选的，但使用 try 语句时必须至少使用一个。</p><ol><li> 如果try语句没有使用finally，则返回try语句中return的东西，</li></ol><p>   ​    函数try…catch语句之外的return 就不执行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">1</span>;<span class="comment">//return这里的值11</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">5</span>; <span class="comment">//无效，没执行到这，try...catch执行之后就跳出了</span></span><br><span class="line">    <span class="comment">//除非try...catch...finaly语句中没有return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(testFinally());<span class="string">``</span><span class="comment">//11</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 如果try语句后面有finally，try中的return不会跳出函数,因为一定要进入finally语句</li></ol><p>​    函数try…finally语句之外的return 就不执行了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num += <span class="number">1</span>; <span class="comment">//return右边的语句正常执行，计算得num=11</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;        <span class="comment">//有finally，try中的return不会跳出函数，因为一定要进入finally语句</span></span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">20</span>; <span class="comment">//11+20=31</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">5</span>; <span class="comment">//无效，没执行到这，try...finally执行之后就跳出了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(testFinally())；<span class="comment">// 31</span></span><br></pre></td></tr></table></figure><ol start="3"><li>如果try语句后面有finally，try中就算有break用来跳出语句块，也不管用<pre><code>只要有finally，不管try和catch语句中执行什么，一定会进入finally语句</code></pre></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFinally</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    aaa: <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">break</span> aaa; <span class="comment">//有break按理说应该要跳出 try...finally... 这个语句块了</span></span><br><span class="line">                   <span class="comment">//但是不管用，因为后面有finally，一定要进入finally语句</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;         </span><br><span class="line">        <span class="keyword">return</span> num + <span class="number">20</span>; <span class="comment">//10+20=30</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;<span class="comment">//失效，没执行到这</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(testFinally());<span class="comment">// 30</span></span><br></pre></td></tr></table></figure><h5 id="break"><a href="#break" class="headerlink" title="break"></a>break</h5><p>break语句用于跳出 switch语句 或者 循环语句（ for 、for..in、while、do…while） </p><p>  语法：break;</p><blockquote><p>1）当break语句用于switch语句时，会跳出switch代码块，终止执行switch代码。</p></blockquote><blockquote><p>2）当break语句用于循环语句时，会跳出整个循环，不再执行后续剩余的循环。</p></blockquote><blockquote><p>3）注意break与continue的区别：continue会跳出本轮循环，继续执行后续剩余的循环</p></blockquote><ol><li> 在标签引用中使用 break 语句，用于跳出标签代码块：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars = [<span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;Volvo&quot;</span>, <span class="string">&quot;Saab&quot;</span>, <span class="string">&quot;Ford&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">list: &#123; <span class="comment">//list标签引用</span></span><br><span class="line">    text += cars[<span class="number">0</span>];</span><br><span class="line">    text += cars[<span class="number">1</span>];</span><br><span class="line">    text += cars[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">break</span> list; <span class="comment">//在标签引用中使用 break 语句，用于跳出list代码块，不再执行list代码块里剩余的代码</span></span><br><span class="line">    text += cars[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(text);<span class="comment">//BMW Volvo Saab</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在标签引用中使用 break 语句，用于跳出嵌套循环：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> i, j;</span><br><span class="line"> </span><br><span class="line">Loop1: <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 第一个循环标签 &quot;Loop1&quot;</span></span><br><span class="line">    <span class="attr">Loop2</span>: <span class="keyword">for</span> (j = <span class="number">10</span>; j &lt; <span class="number">15</span>; j++) &#123;<span class="comment">// 第二个循环标签 &quot;Loop2&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">12</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> Loop2;<span class="comment">//跳出Loop2代码块</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(i, j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i=0,j=10</span></span><br><span class="line"><span class="comment">//i=0,j=11</span></span><br><span class="line"><span class="comment">//i=1,j=10</span></span><br><span class="line"><span class="comment">//i=1,j=11</span></span><br><span class="line"><span class="comment">//1=2,j=10</span></span><br><span class="line"><span class="comment">//i=2,j=11</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;预编译习题&quot;&gt;&lt;a href=&quot;#预编译习题&quot; class=&quot;headerlink&quot; title=&quot;预编译习题&quot;&gt;&lt;/a&gt;预编译习题&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;预编译&lt;/strong&gt;：作用域的创建阶段&lt;/p&gt;
&lt;p&gt;JS的变量对象 AO对象 供JS引擎自己去</summary>
      
    
    
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>node</title>
    <link href="http://example.com/2022/03/20/node/"/>
    <id>http://example.com/2022/03/20/node/</id>
    <published>2022-03-20T13:53:19.000Z</published>
    <updated>2022-03-27T14:36:33.889Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>设计架构</title>
    <link href="http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2022/03/20/%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84/</id>
    <published>2022-03-20T13:53:09.000Z</published>
    <updated>2022-03-20T13:53:09.501Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-20T13:52:51.000Z</published>
    <updated>2022-03-31T13:44:18.270Z</updated>
    
    <content type="html"><![CDATA[<p>  操作系统（Operating System 简称OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。</p><p>简单来讲，操作系统就是一种复杂的软件，相当于软件管家。</p><p>操作系统需要处理如管理与配置内存</p><p>、决定系统资源工序的优先次序，控制输入与输出设备、操作网络与管理文件系统等基本事务。</p><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol><li>进程（线程）：是操作对象CPU的抽象</li><li>虚拟地址（地址空间）：是操作系统对物理内存的抽象</li><li>文件：操作系统对物理磁盘的抽象</li><li>shell：是一个程序，可从键盘获取命令并将其提供给操作系统以执行</li><li>GUI：是一种用户界面，允许用户通过图形图标和音频指示符与电子设备进行交互 </li><li>计算机架构（computer architecture）:在计算机工程中，计算机体系结构是描述计算机系统功能，组织和实现的一组规则和方法。他主要包括指令集、内存管理、I/O和总线结构。</li><li>多处理系统（(Computer multitasking）指计算机同时运行多个程序的能力</li><li>程序计数器（Program counter）程序计数器 是一个CPU中的寄存器，用于指示计算机在其程序序列中的位置</li><li>多线程（multithreading）：是指从软件或者硬件上实现多个线程并发执行的技术</li><li>CPU核心（core）：是cpu的大脑，它接收指令，并执行计算或运算以满足这些指令。一个CPU可以有多个内核</li><li>图形处理器（Graphics Processing Unit）：又称显示核心、视觉处理器、显示芯片或绘图芯片</li><li>缓存命中(cache hit)：当应用程序或软件请求数据时，会首先发生缓存命中</li><li>RAM((Random Access Memory)：随机存取存储器，也叫主存，是与 CPU 直接交换数据的内部存储器</li><li>ROM (Read Only Memory)：只读存储器是一种半导体存储器，其特性是一旦存储数据就无法改变或删除</li><li>虚拟地址(virtual memory)： 虚拟内存是计算机系统内存管理的一种机制</li><li>驱动程序(device driver)：设备驱动程序，简称驱动程序（driver），是一个允许高级别电脑软件与硬件交互的程序</li><li>USB(Universal Serial Bus)：是连接计算机系统与外部设备的一种串口总线标准，也是一种输入输出接口的技术规范</li><li>地址空间(address space)：地址空间是内存中可供程序或进程使用的有效地址范</li><li>进程间通信(interprocess communication)： 指至少两个进程或线程间传送数据或信号的一些技术或方法</li><li>目录(directory)： 在计算机或相关设备中，一个目录或文件夹就是一个装有数字文件系统的虚拟容器</li><li>路径(path name)： 路径是一种电脑文件或目录的名称的通用表现形式，它指向文件系统上的一个唯一位置。</li><li>根目录(root directory)：根目录指的就是计算机系统中的顶层目录，比如 Windows 中的 C 盘和 D 盘，Linux 中的 /</li><li>工作目录(Working directory)：它是一个计算机用语。用户在操作系统内所在的目录，用户可在此目录之下，用相对文件名访问文件。</li><li>文件描述符(file descriptor)： 文件描述符是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念</li><li>客户端(clients)：客户端是访问服务器提供的服务的计算机硬件或软件。</li><li>服务端(servers)： 在计算中，服务器是为其他程序或设备提供功能的计算机程序或设备</li></ol><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是对正在运行中的程序的一个抽象，<strong>是系统进行资源分配和调度的基本单位</strong>。操作系统的其他所有内容都是围绕着进程展开的，负责执行这些任务的是CPU。</p><p>进程是一种抽象的概念，一般是由程序（用于描述进程要完成的功能，是控制进程执行的指令集）、数据集合（是程序在执行时所需要的数据和工作区）和进程控制块（包含进程的描述信息和控制信息，是进程存在的唯一标志）三部分组成。</p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>操作系统能够进行运算调度的最小单位，是进程中的一个执行任务（控制单元），负责当前进程中程序的执行。</p><p><strong>一个进程至少有一个线程，一个进程可以运行多个线程</strong>。这些线程共享同一块内存，线程之间可以共享对象、资源，如果有冲突或需要协同，还可以随时沟通以解决冲突或保持同步。</p><p><strong>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</strong></p><p><strong>在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</strong></p><p><strong>在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</strong></p><p><strong>没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</strong></p><p>举个例子：进程=火车，线程=车厢</p><ul><li>线程在进程下行进（单纯的车厢无法运行）</li><li>一个进程可以包含多个线程（一辆火车可以有多个车厢）</li><li>不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）</li><li>同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）</li><li>进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去。此时成系统处于思索状态或系统产生了死锁。这些永远都在互相等待的进程成为思索进程。产生死锁的原因，主要包括：</p><ol><li>系统资源不足</li><li>程序执行的顺序有问题</li><li>资源分配不当</li></ol><p>如果在一个系统中以下四个条件同时成立，那么就能引起死锁：</p><ul><li><p>互斥条件：一个资源每次只能被一个进程使用</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放</p></li><li><p>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</p></li><li><p>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ul><h5 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h5><h6 id="鸵鸟策略："><a href="#鸵鸟策略：" class="headerlink" title="鸵鸟策略："></a>鸵鸟策略：</h6><p>发生死锁时不去管它，因为处理死锁的代价很高，反而不处理它会带来更高的性能。当死锁不易发生或者发生死锁对用户的影响不是很大时采取这种策略。Windows、Linux、Unix会采用这种策略。</p><h6 id="死锁的检测与恢复："><a href="#死锁的检测与恢复：" class="headerlink" title="死锁的检测与恢复："></a>死锁的检测与恢复：</h6><p>涉及死锁检测算法2个：<br>第一个死锁检测算法：深度搜索进程资源有向图<br><strong>若进程资源有向图中存在环路</strong>，表明发生死锁。<strong>检测方式为深度优先搜索</strong>，对搜索的节点做标记，若遍历到存在标记的节点，表明该有向图存在环路，会发生死锁。<br>第二个死锁检测算法：标记法<br>向量E代表资源总数，向量A代表剩余资源，<br>矩阵C代表各进程持有资源数，矩阵R代表各进程要请求的资源数。<br>算法的记忆方式就是RACA，先从R中找到请求资源数小于A的进程，并标记该进程，意味着该进程可以请求到自己所需的资源，之后释放持有资源，将C中该进程持有资源加到原来的A向量中，即完成了释放资源。再重复RACA，直到最后R中存在没有被标记的进程代表会发生死锁，否则不会发生死锁。<br>死锁恢复算法若干：</p><ol><li>资源剥夺法：剥夺发生死锁的进程锁持有的资源，但不撤销该进程，直到进程解除死锁。</li><li>进程回滚法：设定检查点，让发生死锁的进程回滚，直到解除死锁。要求建立保存检查点、回退及重启机制。</li><li>杀死进程。</li></ol><h6 id="死锁预防："><a href="#死锁预防：" class="headerlink" title="死锁预防："></a>死锁预防：</h6><p><strong>破坏互斥条件</strong>：若资源为共享资源，则不会发生死锁。一般情况下，有些资源是不允许共享访问的，比如可写文件、键盘等。当然有些资源时可以共享访问的，例如只读文件和磁盘。因此，破坏互斥条件只适用于一部分资源。当然，操作系统的SPOOLING技术能够让独占设备在逻辑上看起来是被共享。但是很多时候，我们需要使用互斥条件来保证进程的安全。</p><p><strong>破坏请求和保持条件</strong>：若进程持有一部分资源且申请其他资源时，由于它不会释放自己持有的资源，可能会发生死锁。因此解决方法可以是在程序运行前，将其所需要的全部资源都分配给该进程，但是这种方式会造成资源的浪费，因为它所持有的资源可能需要到运行后期才使用，又或者某些资源的运行时间很短，会导致一些其他期望持有该资源的进程等待，进而可能产生进程饥饿，造成资源的浪费，资源利用率降低。</p><p><strong>破坏不可剥夺条件</strong>：方案一：当进程持有资源而申请其他资源得不到满足时，强迫其释放所持有的资源，需要时再次申请。方案二：当进程请求的资源被其他进程占有，由操作系统协调剥夺其他进程占有的资源。该种方式需要考虑进程运行时的优先级。<br>方案一可能会导致前期所做的工作失效；方案二可能会导致被剥夺进程前期所做的工作失效。</p><p><strong>破坏循环等待条件</strong>：将资源按顺序编号，只能按顺序递增的方式申请资源。不易增加新的设备，进程实际运行的顺序可能和资源编号不一致，导致资源浪费，必须按规定次序申请资源，用户编程麻烦。</p><h6 id="死锁避免："><a href="#死锁避免：" class="headerlink" title="死锁避免："></a>死锁避免：</h6><p>安全状态：简单的口述一下，目前状态已知的条件为占有的资源，要请求的资源，剩余的资源，进程申请资源并释放，最后若能够保证所有进程都执行，那么该状态为安全状态。<br>银行家算法：银行家算法是死锁避免中最重要的算法。其核心思想就是为进程分配资源并判断分配后是否是安全状态，若是，则分配，否则，不会分配。若能够满足全部进程的资源请求，则不会发生死锁。给每个进程分配资源的过程会产生一条安全序列，就是进程分配资源的顺序。</p><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>是一个开源的操作系统（OS），是一系列linux内核基础上开发的操作系统的总称。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  操作系统（Operating System 简称OS）是一组主管并控制计算机操作、运用和运行硬件、软件资源和提供公共服务来组织用户交互的相互关联的系统软件程序，同时也是计算机系统的内核与基石。&lt;/p&gt;
&lt;p&gt;简单来讲，操作系统就是一种复杂的软件，相当于软件管家。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-03-20T13:52:39.000Z</published>
    <updated>2022-03-31T13:36:38.522Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>带有结构特性的数据元素的集合,他研究的是数据的逻辑结构和数据的物理结构以及他们之间的相互关系，并对这种结构定义相适应的运算，设计出相应的算法，并确保经过这些运算以后所得到的新结构仍然保持原来的结构类型。简而言之，数据结构是相互之间存在一种或多种特定关系的数据元素的集合，即带“结构”的数据元素的集合。“结构”就是指数据元素之间存在的关系，分为逻辑结构和存储结构。</p><p>数据是存储在计算机内存里的，在存储是，决定了数据顺序和位置关系的便是“数据结构”。</p><p><strong>逻辑结构</strong>：元素之间逻辑关系的数据结构，这里的逻辑关系是指数据元素之间的前后间关系，与数据在计算机中的存储位置无关。</p><p><strong>物理结构</strong>：指数据的逻辑结构在计算机存储空间中的存放形式称为数据的物理结构，也叫做存储结构。</p><p><a href="https://zhuanlan.zhihu.com/p/138523723">十三张图带你彻底了解所有数据结构 - 知乎 (zhihu.com)</a></p><h4 id="时间复杂度，空间复杂度"><a href="#时间复杂度，空间复杂度" class="headerlink" title="时间复杂度，空间复杂度"></a>时间复杂度，空间复杂度</h4><p>算法是指用来操作数据、解决程序问题的一组方法问题，使用不同的算法，也许最终得到的结果是一样的，但在过程和时间却会有很大的区别。</p><h6 id="时间维度："><a href="#时间维度：" class="headerlink" title="时间维度："></a>时间维度：</h6><p>算法的复杂度通常用大O表述，定义为：T(n)=O(f(n))</p><p>时间复杂度：O(1)常数型、O(log n)对数型、O(n)线性型、O(nlogn)线性对数型、O(n^2)平方型、O(n^3)立方型、O(n^k)k次方型、O(2^n)指数型</p><p><strong>计算时间复杂度的方法</strong></p><ol><li>找出算法中的基本语句</li></ol><p>算法中执行次数最多的那条语句就是基本语句，通常是最内层循环的循环体</p><ol><li>计算基本语句的执行次数的数量级</li></ol><p>保留最高次幂</p><ol><li>用大O几号表示算法的时间性能</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//性能最好的算法的时间复杂度为 O(1)，也就是在执行有限次的操作之后达到目标。比如一些计算类型的代码或者交换值的代码等。</span></span><br><span class="line"><span class="comment">//1.计算</span></span><br><span class="line"><span class="keyword">var</span> sum = a * b;</span><br><span class="line"><span class="comment">//2.交换</span></span><br><span class="line"><span class="keyword">var</span> temp = a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//o(n)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aFunc</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 循环次数为 n</span></span><br><span class="line">        printf(<span class="string">&quot;Hello, World!\n&quot;</span>); <span class="comment">// 循环体时间复杂度为 O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于顺序执行的语句，总的时间复杂度等于其中最大的时间复杂度，//max(O(n^2), O(n)) = O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环语句中以2的倍数来逼近n   时间复杂度为 log n</span></span><br><span class="line"><span class="comment">//如果一个O(n)里面嵌套一个O(logn)那么时间复杂度为O(nlogn)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        i = i * <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="空间维度"><a href="#空间维度" class="headerlink" title="空间维度"></a>空间维度</h6><p>空间复杂度主要指执行算法所需内存大小，用于对程序运行过程中所需要的临时存储空间的度量.</p><p>除了需要存储空间、指令、常数、变量和输入数据外，还包括对数据进行操作的工作单元和存储计算所需信息的辅助空间</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(1) 临时空间不会随着n的变化而变化，因此空间复杂度为O(1)</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span></span><br><span class="line"><span class="comment">//o(n) 随着n的增加，数组的占用的内存空间越大</span></span><br><span class="line"><span class="keyword">let</span> arr []</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)&#123;</span><br><span class="line">  arr.push(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为O(1)，一个一维数组a[n]，空间复杂度O(n)，二维数组为O(n^2)</span></span><br></pre></td></tr></table></figure><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p><strong>树（Tree）</strong>是n（n&gt;=0)个结点的有限集。n=0时称为空树。</p><p>2）当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、……、Tn，其中每一个集合本身又是一棵树，并且称为根的子树。</p><p>结点拥有的子树数目称为结点的<strong>度</strong>。</p><p><img src="/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220323155422299.png" alt="image-20220323155422299"></p><p>树中结点的最大层次数称为树的深度或高度。上图所示树的深度为4。</p><p><strong>二叉树</strong></p><p><strong>二叉树</strong>是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。</p><p><img src="/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220323155525631.png" alt="image-20220323155525631"></p><p>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。<br>2）左子树和右子树是有顺序的，次序不能任意颠倒。<br>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p><p><strong>性质</strong></p><p>1）在二叉树的第i层上最多有2^(i-1) 个节点 。（i&gt;=1）<br> 2）二叉树中如果深度为k,那么最多有2^k-1个节点。(k&gt;=1）<br> 3）n0=n2+1  n0表示度数为0的节点数，n2表示度数为2的节点数。<br> 4）在完全二叉树中，具有n个节点的完全二叉树的深度为[log2n]+1，其中[log2n]是向下取整。<br> 5）若对含 n 个结点的完全二叉树从上到下且从左至右进行 1 至 n 的编号，则对完全二叉树中任意一个编号为 i 的结点有如下特性：</p><blockquote><p>(1) 若 i=1，则该结点是二叉树的根，无双亲, 否则，编号为 [i/2] 的结点为其双亲结点;<br> (2) 若 2i&gt;n，则该结点无左孩子，  否则，编号为 2i 的结点为其左孩子结点；<br> (3) 若 2i+1&gt;n，则该结点无右孩子结点，  否则，编号为2i+1 的结点为其右孩子结点。</p></blockquote><h5 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h5><ol><li>前序  中左右</li><li>中序  左中右</li><li>后序  左右中</li><li>层序 按照二叉树的层次从左到右一次遍历每层中的结点</li></ol><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>对与排序算法的好坏衡量，主要是从时间复杂度、空间复杂度、稳定性。</p><p>稳定性指的是假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变</p><p>即在原序列中，r[i] = r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的；否则称为不稳定的.</p><p><img src="/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220325105005837.png" alt="image-20220325105005837"></p><p><strong>常见排序算法</strong></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><p>思路：</p><ol><li>比较相邻的元素，如果第一个比第二个大，就交换他们两个，</li><li>在每一对相邻的元素作同样的工作，</li><li>针对所有元素重复以上步骤，直到没有任何一对数字需要比较</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;        <span class="comment">// 相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">// 元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><p>无论什么数据进去都是O（n2）的复杂度，所以使用它时，数据规模越小越好，唯一的好处是不占用额外的内存存储空间</p><p>思路：</p><ol><li>在未排序的序列中找到最大（小）存放在排序序列的起始位置；</li><li>从剩余未排序元素中继续寻找最大（小）的元素，然后放到已排序的序列末尾；</li><li>重复第二步。直到排序完成</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h5><p>通过构建有序序列，对于未排序序列，在已排序序列中从后向前扫描，找到相应位置插入</p><p>思路：</p><ol><li>把待排序的数组分成已排序和未排序两个部分，</li><li>初始的时候把第一个元素认为是已排好序的，第一个元素至末尾都是魏排序数组，在未排序序列中选出第一个元素在已排序序列中进行比较，找到合适的位置并插入该位置（如果已经有相同元素，则插在相同元素后面）；</li><li>重复动作直至之后一个元素被插入</li></ol><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><p>采用分治法。将已有序的子序列合并，得到完全有序的序列，即先使每个子序列有序，再使子序列段有序。</p><p>思路：</p><ol><li>申请空间，使其大小魏两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的其实位置</li><li>比较两个指针所指向的元素，选择相对较小的元素放入到合并空间，并移动指针到下一位置</li><li>重复步骤三直到某一指针到达序列尾</li><li>将另一序列剩下的所有元素直接1赋值到合并序列</li></ol><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><p>对冒泡排序的一种改进，基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行跨苏排序，整个拍戏过程可以地柜进行。</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot）</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> rec = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">const</span> left = [];</span><br><span class="line">    <span class="keyword">const</span> right = [];</span><br><span class="line">    <span class="keyword">const</span> mid = arr[<span class="number">0</span>]; <span class="comment">// 基准元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; mid) &#123;</span><br><span class="line">        left.push(arr[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        right.push(arr[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [...rec(left), mid, ...rec(right)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res(arr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h4&gt;&lt;p&gt;带有结构特性的数据元素的集合,他研究的是数据的逻辑结构和数据的物理结构以及他们之间的相互关系，并对这种结构定义相适应的运算，</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>HTTP系列</title>
    <link href="http://example.com/2022/03/20/HTTP/"/>
    <id>http://example.com/2022/03/20/HTTP/</id>
    <published>2022-03-20T13:52:29.000Z</published>
    <updated>2022-07-13T12:21:48.345Z</updated>
    
    <content type="html"><![CDATA[<ol start="2"><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网路</title>
    <link href="http://example.com/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/"/>
    <id>http://example.com/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/</id>
    <published>2022-03-20T13:52:29.000Z</published>
    <updated>2022-04-11T03:56:21.776Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><p>网络（network）是由若干节点和连接这些节点（node）的链路（link）组成，多个网络可以通过路由器连起来，这样就构成了一个覆盖范围更大的网络，即互联网。因特网（Internet）是世界上最大的互联网</p><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220321222538621.png" alt="image-20220321222538621"></p><p><strong>因特网服务提供者ISP（ Internet Service Provider）</strong></p><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220321222708256.png" alt="image-20220321222708256"></p><p><strong>因特网的组成</strong></p><p>边缘部分：由所有连接在因特网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享</p><p>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）</p><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220321223319322.png" alt="image-20220321223319322"></p><p><strong>三种交换方式</strong>(干啥的)</p><p>电路交换</p><p>分组交换</p><p>报文交换</p><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><p>一些互相连接的（计算机之间可以通过有限或者无线进行数据通信）、自治（独立的计算机，有自己的硬件和软件，可以单独运行使用）的计算机集合</p><p>定义：计算机网络主要由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><p><em>计算机网络所连接的硬件，并不局限于一般的计算机，而是包括了智能手机等智能硬件；计算机网络并非专门用来传送数据，而是能够支持很多种的应用</em></p><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220321224210766.png" alt="image-20220321224210766"></p><h5 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h5><ul><li><p>速率</p></li><li><p>带宽</p></li><li><p>吞吐量</p><p>吞吐量表示在单位时间内通过某个网络的（或信道/接口）的数据量</p></li><li><p>时延</p></li><li><p>时延带宽积</p></li><li><p>往返时间</p></li><li><p>利用率</p></li><li><p>丢包率</p></li></ul><h4 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h4><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220325191414226.png"></p><h6 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h6><p>采用怎样的传输媒介，采用怎样的物理接口，使用怎样的信号表示比特0和1.</p><h6 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h6><p>如何标识网络中的各主机（主机编址，例如MAC地址），如何从信号所表示的依赖内存比特流中去根除地址和数据，如何协调各主机争用总线。</p><h6 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h6><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HyperText Transfer Protocol，超文本传输协议，是实现网络通信的一种规范。</p><p>在计算机和网络世界有，存在不同的协议，如广播协议、寻址协议、路由协议等等……</p><p>而<code>HTTP</code>是一个传输协议，即将数据由A传到B或将B传输到A，并且 A 与 B 之间能够存放很多第三方，如： A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B</p><p>传输的数据并不是计算机底层中的二进制包，而是完整的、有意义的数据，如HTML 文件, 图片文件, 查询结果等超文本，能够被上层应用识别。</p><p><strong>在实际应用中，<code>HTTP</code>常被用于在<code>Web</code>浏览器和网站服务器之间传递信息，以明文方式发送内容，不提供任何方式的数据加密</strong>。</p><h6 id="特点如下："><a href="#特点如下：" class="headerlink" title="特点如下："></a>特点如下：</h6><ul><li>支持客户/服务器模式</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</li><li>无状态：HTTP协议无法根据之前的状态进行本次的请求处理</li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p><code>HTTP</code>传递信息是以明文的形式发送内容，这并不安全。而<code>HTTPS</code>出现正是为了解决<code>HTTP</code>不安全的特性。</p><p>为了保证这些隐私数据能加密传输，让<code>HTTP</code>运行安全的<code>SSL/TLS</code>协议上，即 HTTPS = HTTP + SSL/TLS，<strong>通过 <code>SSL</code>证书来验证服务器的身份</strong>，并为浏览器和服务器之间的通信进行加密。</p><p><code>SSL</code> 协议位于<code>TCP/IP</code> 协议与各种应用层协议之间，浏览器和服务器在使用 <code>SSL</code> 建立连接时需要选择一组恰当的加密算法来实现安全通信，为数据通讯提供安全支持</p><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220325182826253.png" alt="image-20220325182826253"></p><p><img src="/2022/03/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF/image-20220325182924900.png" alt="image-20220325182924900"></p><ul><li>首先客户端通过URL访问服务器建立SSL连接</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li><li>服务器利用自己的私钥解密出会话密钥</li><li>服务器利用会话密钥加密与客户端之间的通信</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全</li><li>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443</li><li>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP</li><li>HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高</li></ul><p><a href="https://blog.csdn.net/wangtaomtk/article/details/80917081">深入浅出HTTPS工作原理_xinjing_wangtao的博客-CSDN博客_https原理</a></p><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>三次握手四次挥手    UDP/TCP</p><h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p>实际操作</p><h4 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h4><h4 id="从输入URL到页面加载的全过程"><a href="#从输入URL到页面加载的全过程" class="headerlink" title="从输入URL到页面加载的全过程"></a>从输入URL到页面加载的全过程</h4><ol><li>浏览器地址栏输入URL</li><li>浏览器查看缓存</li></ol><h4 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h4><p><a href="https://juejin.cn/post/6844903593275817998">https://juejin.cn/post/6844903593275817998</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h4&gt;&lt;p&gt;网络（network）是由若干节点和连接这些节点（node）的链路（link）组成，多个网络可以通过路由器连起来，这样就构成了一个覆盖范围更</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>错题</title>
    <link href="http://example.com/2022/03/20/%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://example.com/2022/03/20/%E7%BC%96%E7%A8%8B%E9%A2%98/</id>
    <published>2022-03-20T13:52:20.000Z</published>
    <updated>2022-04-23T12:14:52.123Z</updated>
    
    <content type="html"><![CDATA[<h5 id><a href="#" class="headerlink" title></a></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a=b=<span class="number">5</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">//函数作用=&gt;不必为函数命名，避免了污染全局变量</span></span><br><span class="line"><span class="comment">//立即函数内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量</span></span><br><span class="line"><span class="comment">//这里只有a被声明了,b被解析为全局变量</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2022/03/20/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2022/03/20/%E7%AE%97%E6%B3%95/</id>
    <published>2022-03-20T13:52:08.000Z</published>
    <updated>2022-04-12T02:17:40.162Z</updated>
    
    <content type="html"><![CDATA[<h5 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">fib</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n===<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="合并链表（保持递增）"><a href="#合并链表（保持递增）" class="headerlink" title="合并链表（保持递增）"></a>合并链表（保持递增）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] === arr[i]) &#123;</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">3.</span></span><br></pre></td></tr></table></figure><h5 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatter</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">let</span> arr2 = []</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">               <span class="built_in">console</span>.log(value)</span><br><span class="line">               <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">                   <span class="comment">// arr2 = arr2.concat(flatter(value))</span></span><br><span class="line">                   arr2 = arr2.concat(...value)</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                   arr2.push(value)</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> arr2;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h5 id="数组指定位置插入元素"><a href="#数组指定位置插入元素" class="headerlink" title="数组指定位置插入元素"></a>数组指定位置插入元素</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">splice(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;asdk&quot;</span>)</span><br><span class="line">push()尾部添加 pop()尾部删除</span><br><span class="line">unshift()头部添加 shift()头部删除</span><br></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="用setinterval实现setTimeout"><a href="#用setinterval实现setTimeout" class="headerlink" title="用setinterval实现setTimeout"></a>用setinterval实现setTimeout</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myset</span>(<span class="params">delay, count</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count&lt;<span class="number">0</span>)<span class="keyword">return</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;hahah&quot;</span>, count)</span><br><span class="line">        myset(delay, --count)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="去掉空格"><a href="#去掉空格" class="headerlink" title="去掉空格"></a>去掉空格</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trim</span><br><span class="line">replace(/^\s*|\s*$/g,&quot;&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="判断一个数是否是素数"><a href="#判断一个数是否是素数" class="headerlink" title="判断一个数是否是素数"></a>判断一个数是否是素数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//素数不能被2~m-1的所有数整除，只能被1和他本身整除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 只要2到num - 1 之间有一个数能被num整除 那么就不是质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h5 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h5><h5 id="如果九宫格密码，最少连接4个点，最多连接9个点，那么有多少连接方式？有多少个密码"><a href="#如果九宫格密码，最少连接4个点，最多连接9个点，那么有多少连接方式？有多少个密码" class="headerlink" title="如果九宫格密码，最少连接4个点，最多连接9个点，那么有多少连接方式？有多少个密码"></a>如果九宫格密码，最少连接4个点，最多连接9个点，那么有多少连接方式？有多少个密码</h5><h5 id="假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。"><a href="#假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。" class="headerlink" title="假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。"></a>假设现有100元的商品，而代金券有50元、30元、20元、5元四种，则最佳优惠是两张50元面额的代金券；而如果现有65元的商品，则最佳优惠是两张30元代金券以及一张5元代金券。</h5><h5 id="给定一个包含非负整数的-M-x-N-迷宫，请找出一条从左上角到右下角的路径，使得路径上的数字总和最小。每次只能向下或者向右移动一步。"><a href="#给定一个包含非负整数的-M-x-N-迷宫，请找出一条从左上角到右下角的路径，使得路径上的数字总和最小。每次只能向下或者向右移动一步。" class="headerlink" title="给定一个包含非负整数的 M x N 迷宫，请找出一条从左上角到右下角的路径，使得路径上的数字总和最小。每次只能向下或者向右移动一步。"></a>给定一个包含非负整数的 M x N 迷宫，请找出一条从左上角到右下角的路径，使得路径上的数字总和最小。每次只能向下或者向右移动一步。</h5><h5 id="已知，1000个硬币里有10个金币。随机的取出n个硬币，则取出硬币里有金币的概率是多少？"><a href="#已知，1000个硬币里有10个金币。随机的取出n个硬币，则取出硬币里有金币的概率是多少？" class="headerlink" title="已知，1000个硬币里有10个金币。随机的取出n个硬币，则取出硬币里有金币的概率是多少？"></a>已知，1000个硬币里有10个金币。随机的取出n个硬币，则取出硬币里有金币的概率是多少？</h5><p>还有一套题没看完，在牛客网上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;斐波那契&quot;&gt;&lt;a href=&quot;#斐波那契&quot; class=&quot;headerlink&quot; title=&quot;斐波那契&quot;&gt;&lt;/a&gt;斐波那契&lt;/h5&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Vue</title>
    <link href="http://example.com/2022/03/20/Vue/"/>
    <id>http://example.com/2022/03/20/Vue/</id>
    <published>2022-03-20T13:51:44.000Z</published>
    <updated>2022-04-02T10:11:36.225Z</updated>
    
    <content type="html"><![CDATA[<h4 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h4><h4 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h4><h5 id="数据驱动（MVVM）"><a href="#数据驱动（MVVM）" class="headerlink" title="数据驱动（MVVM）"></a>数据驱动（MVVM）</h5><p>model：数据模型</p><p>view：ui组件</p><p>viewModel：两者间桥梁</p><p>数据会绑定到viewModel上面，数据发生变化的时候会通知viewModel更新视图。</p><h5 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h5><h5 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h5><p>指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><ul><li>常用的指令<ul><li>条件渲染指令 <code>v-if</code></li><li>列表渲染指令<code>v-for</code></li><li>属性绑定指令<code>v-bind</code></li><li>事件绑定指令<code>v-on</code></li><li>双向数据绑定指令<code>v-model</code></li></ul></li></ul><h4 id="关于双向绑定的理解"><a href="#关于双向绑定的理解" class="headerlink" title="关于双向绑定的理解"></a>关于双向绑定的理解</h4><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>每个Vue实例在创建时期都会经过一系列的初始化过程，vue的生命周期勾子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或事件。vue实例从创建到销毁的过程就是一个vue的生命周期。即指从创建、初始化数据、编译模板、挂载DOM到渲染、更新到渲染、销毁等一系列过程，主要分为创建、挂载、更新、销毁以及一些其他的特殊场景的生命周期</p><ol><li><p><code>create阶段</code>：vue实例被创建</p><pre><code> `beforeCreate`: 创建前，此时data和methods中的数据都还没有初始化`created`： 创建完毕，data中有值，未挂载</code></pre></li><li><p><code>mount阶段</code>： vue实例被挂载到真实DOM节点</p><pre><code> `beforeMount`：可以发起服务端请求，去数据 `mounted`: 组件挂载到实例上去之后，此时可以操作DOM</code></pre></li><li><p><code>update阶段</code>：当vue实例里面的data数据变化时，触发组件的重新渲染</p><pre><code>  `beforeUpdate` :组件数据发生变化，更新前     `updated`：更新后</code></pre></li><li><p><code>destroy阶段</code>：vue实例被销毁</p><pre><code>       `beforeDestroy`：实例被销毁前，此时可以手动销毁一些方法</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//其余特殊组件</span><br><span class="line">activated：keep-alive缓存的组件激活时</span><br><span class="line">deactivated：keep-alive缓存的组件停用时调用</span><br></pre></td></tr></table></figure><p><code> destroyed</code>:销毁后</p></li></ol><p><img src="/2022/03/20/Vue/image-20220324191649514.png" alt="image-20220324191649514"></p><p><img src="/2022/03/20/Vue/image-20220324191827487.png" alt="image-20220324191827487"></p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><h6 id="props父传子"><a href="#props父传子" class="headerlink" title="props父传子"></a>props父传子</h6><p>子组件设置props属性，东一接收父组件传递过来的参数，父组件在使用子组件标签中通过 : data=“data”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props:&#123;  </span><br><span class="line">    <span class="comment">// 字符串形式  </span></span><br><span class="line">     <span class="attr">name</span>:<span class="built_in">String</span> <span class="comment">// 接收的类型参数  </span></span><br><span class="line">    <span class="comment">// 对象形式  </span></span><br><span class="line">    <span class="attr">age</span>:&#123;    </span><br><span class="line">        <span class="attr">type</span>:<span class="built_in">Number</span>, <span class="comment">// 接收的类型为数值  </span></span><br><span class="line">        <span class="attr">defaule</span>:<span class="number">18</span>,  <span class="comment">// 默认值为18  </span></span><br><span class="line">       <span class="attr">require</span>:<span class="literal">true</span> <span class="comment">// age属性必须传递  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h6 id="emit子传父"><a href="#emit子传父" class="headerlink" title="$emit子传父"></a>$emit子传父</h6><p>子组件通过$emit触发自定义事件，$emit第二个参数魏传递的数值；父组件绑定检同期获取子组件传递过来的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子</span></span><br><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&#x27;add&#x27;</span>, good)  </span><br><span class="line"><span class="comment">//父</span></span><br><span class="line">&lt;Children @add=<span class="string">&quot;cartAdd($event)&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h6 id="EventBus兄弟传值"><a href="#EventBus兄弟传值" class="headerlink" title="EventBus兄弟传值"></a>EventBus兄弟传值</h6><p>创建一个中央事件总线 EventBus，兄弟组件通过$emit触发自定义事件，$emit第二个参数作为传递的数值。另一个兄弟组件通过$on监听自定义事件。</p><h6 id="vuex-负责复杂关系的组件数据传递"><a href="#vuex-负责复杂关系的组件数据传递" class="headerlink" title="vuex 负责复杂关系的组件数据传递"></a>vuex 负责复杂关系的组件数据传递</h6><h6 id="父组件调用子组件方法（ref）"><a href="#父组件调用子组件方法（ref）" class="headerlink" title="父组件调用子组件方法（ref）"></a>父组件调用子组件方法（ref）</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;Father ref=<span class="string">&quot;child&quot;</span>/&gt;</span><br><span class="line"> methods:&#123;</span><br><span class="line">     <span class="function"><span class="title">clickFUnction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">//调用子组件的方法</span></span><br><span class="line">         <span class="built_in">this</span>.$refs[child].function()</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="子组件通过props调用父组件方法"><a href="#子组件通过props调用父组件方法" class="headerlink" title="子组件通过props调用父组件方法"></a>子组件通过props调用父组件方法</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line">&lt;Father :clickFUnction=<span class="string">&quot;clickFUnction&quot;</span>/&gt;</span><br><span class="line"> methods:&#123;</span><br><span class="line">     <span class="function"><span class="title">clickFUnction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&quot;clickFUnction&quot;</span>]</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clickFUnction()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><h4 id="vue2与vue3"><a href="#vue2与vue3" class="headerlink" title="vue2与vue3"></a>vue2与vue3</h4><ol><li>利用新的语言特性(ES6)</li><li>解决架构问题</li></ol><ul><li>速度更快</li><li>体积减少</li><li>更易维护</li><li>更接近原生</li><li>更易使用</li></ul><h4 id="封装组件"><a href="#封装组件" class="headerlink" title="封装组件"></a>封装组件</h4><h4 id="vue与react的对比"><a href="#vue与react的对比" class="headerlink" title="vue与react的对比"></a>vue与react的对比</h4><p><strong>相同</strong></p><ul><li>都有组件化思想</li><li>都支持服务器端渲染</li><li>都有Virtual DOM（虚拟dom）</li><li>数据驱动视图</li><li>都有支持native的方案：<code>Vue</code>的<code>weex</code>、<code>React</code>的<code>React native</code></li><li>都有自己的构建工具：<code>Vue</code>的<code>vue-cli</code>、<code>React</code>的<code>Create React App</code></li></ul><p><strong>不同</strong></p><ul><li>数据流向的不同。<code>react</code>从诞生开始就推崇单向数据流，而<code>Vue</code>是双向数据流</li><li>数据变化的实现原理不同。<code>react</code>使用的是不可变数据，而<code>Vue</code>使用的是可变的数据</li><li>组件化通信的不同。<code>react</code>中我们通过使用回调函数来进行通信的，而<code>Vue</code>中子组件向父组件传递消息有两种方式：事件和回调函数</li><li>diff算法不同。<code>react</code>主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。<code>Vue</code> 使用双向指针，边对比，边更新DOM</li></ul><h4 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h4><p><strong>computed计算属性 ，</strong></p><p>它会根据所依赖的数据动态显示新的计算结果, 该计算结果会被缓存起来。computed的值是会被缓存的。如果所依赖的数据发生改变时候, 就会重新计算最新的结果,不支持异步，当computed内有异步操作时无效，无法监听数据的变化。如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed</p><p><strong>watch：侦听属性</strong></p><p>不支持缓存，数据变，直接会触发相应的操作,watch支持异步；监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；当一个属性发生变化时，需要执行对应的操作；一对多；</p><p><a href="https://juejin.cn/post/6917805693860839431">详解Vue中的computed和watch - 掘金 (juejin.cn)</a></p><p>虚拟DOM 与 Key 与Diff</p><p><a href="https://vue3js.cn/interview/vue/key.html#%E4%B8%89%E3%80%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">面试官：你知道vue中key的原理吗？说说你对它的理解 | web前端面试 - 面试官系列 (vue3js.cn)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;底层实现原理&quot;&gt;&lt;a href=&quot;#底层实现原理&quot; class=&quot;headerlink&quot; title=&quot;底层实现原理&quot;&gt;&lt;/a&gt;底层实现原理&lt;/h4&gt;&lt;h4 id=&quot;核心特性&quot;&gt;&lt;a href=&quot;#核心特性&quot; class=&quot;headerlink&quot; title=&quot;核</summary>
      
    
    
    
    
    <category term="Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://example.com/2022/03/20/webpack/"/>
    <id>http://example.com/2022/03/20/webpack/</id>
    <published>2022-03-20T13:51:31.000Z</published>
    <updated>2022-03-20T13:51:31.721Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>堆和栈</title>
    <link href="http://example.com/2022/03/19/%E5%A0%86%E5%92%8C%E6%A0%88/"/>
    <id>http://example.com/2022/03/19/%E5%A0%86%E5%92%8C%E6%A0%88/</id>
    <published>2022-03-19T10:50:52.000Z</published>
    <updated>2022-03-20T13:49:55.231Z</updated>
    
    <content type="html"><![CDATA[<h5 id="在不同场景下，堆和栈代表不同的含义。"><a href="#在不同场景下，堆和栈代表不同的含义。" class="headerlink" title="在不同场景下，堆和栈代表不同的含义。"></a>在不同场景下，堆和栈代表不同的含义。</h5><ul><li>在程序内存中，堆与栈表示两种内存管理方式；</li><li>在数据结构场景下，堆与栈表示两种常用的数据结构。</li></ul><h5 id="在程序内存中："><a href="#在程序内存中：" class="headerlink" title="在程序内存中："></a><strong>在程序内存中：</strong></h5><p>栈用来存储函数的参数、局部变量，先进后出。堆由开发人员分配和释放，若开发人员不释放，程序结束时由OS（操作系统）回收。</p><h5 id="在数据结构中"><a href="#在数据结构中" class="headerlink" title="在数据结构中"></a><strong>在数据结构中</strong></h5><h6 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h6><p>栈是一种运算受限的线性表，其限制是指至今允许在表的一段进行插入和删除操作（栈顶），具有FILO（先进后出）特性。</p><p>栈分为顺序栈和链表栈两种。栈是一种线性结构，所以可以用数组&lt;顺序栈&gt;或链表（单项链表、双向链表、循环链表）&lt;链式栈&gt;作为底层数据结构。区别为顺序栈中的元素是连续的，而链式栈中的元素地址不连续。</p><h6 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h6><p>堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值得完全二叉树北辰之威堆。堆的这一特性称之为堆序性，因此，在一个堆中，根节点要么是最大节点要么是最小节点。</p><p>堆的存储一般用数组来存储。i节点的父节点下标就为( i – 1 ) / 2 ，它的左右子节点下标分别为 2 ∗ i +1 和 2 ∗ i + 2 </p><p>所以为什么，基本数据类型和引用数据类型用不同的存储方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;在不同场景下，堆和栈代表不同的含义。&quot;&gt;&lt;a href=&quot;#在不同场景下，堆和栈代表不同的含义。&quot; class=&quot;headerlink&quot; title=&quot;在不同场景下，堆和栈代表不同的含义。&quot;&gt;&lt;/a&gt;在不同场景下，堆和栈代表不同的含义。&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS</title>
    <link href="http://example.com/2022/03/19/JS/"/>
    <id>http://example.com/2022/03/19/JS/</id>
    <published>2022-03-19T09:00:40.000Z</published>
    <updated>2022-04-11T14:50:15.424Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>基本类型</p><p>Number，String，Boolean，Symbol，null，undefined</p><p>在内存中固定大小，保存在栈内存中</p><p>引用类型</p><p>Object，Function，Array这种值是对象，保存在堆（stack）中，栈中存储的是对象的变量标识符以及对象在堆（heap）内存中的存储地址。</p><p><strong>区别</strong></p><ol><li>基本数据类型的值是固定的，直接存储在变量访问的位置，存储在内存相对较小的栈中，可以更加迅速的产找变量的值。引用数据类型在栈中保存的是引用地址，这是因为引用数据类型的值本身是可变的，放在栈中会降低变量查询速度，而地址的大小是固定的，所以把他存储在栈中对变量性能无任何负面影响。</li><li>在JS中不允许直接放在保存在堆内存中的对象，智能按引用访问。</li><li>基本数据类型赋值后相互独立，引用类型赋值赋的是引用地址（指针），所以他们指向堆中的同一个对象。加入其中一个改变了，实际上改变了堆内存对象所以，任一引用值都会改变。</li></ol><h5 id="数据类型检验方案"><a href="#数据类型检验方案" class="headerlink" title="数据类型检验方案"></a>数据类型检验方案</h5><p><strong>typeof</strong></p><p>用法：typeof sth</p><p>缺点：不能区分null，undefined，object，因为都会返回Object</p><p><strong>instanceof</strong></p><p>用法：sth instanceof 类型</p><p>可以判断不同object（除了null），但是不能判断Number，Boolean，String</p><p>原理：只要右边变量的prototype在左边的原型链上即可。</p><p><strong>Object.prototype.toString.call()</strong></p><p>用法：Object.prototype.toString.call(sth) </p><p>可以精准判断</p><p>null（空值 。栈中的变量没有指向堆中的内存对象。空指针）和undefined(未定义的值)</p><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>JS的每个函数在创建的时候，都会有一个prototype属性，这个属性指向一个对象，这个对象就是是这个函数的原型对象。这个对象有个constructor属性，这个属性指向该函数。</p><h5 id="原型链："><a href="#原型链：" class="headerlink" title="原型链："></a>原型链：</h5><p>构造函数创建出来的实例对象，其本身有个属性_ proto _，指向实例对象的构造函数的原型对象。当访问一个对象的属性，会先在这个对象里面的属性上查找，如果找不到，就会在构造函数的原型对象上找，一层一层往上查找形成的链形结构，就是原型链。</p><h5 id="new运算符的实现机制（构造函数创建新对象的过程）"><a href="#new运算符的实现机制（构造函数创建新对象的过程）" class="headerlink" title="new运算符的实现机制（构造函数创建新对象的过程）"></a>new运算符的实现机制（构造函数创建新对象的过程）</h5><ol><li>创建一个新对象</li><li>设置原型，将新对象的原型设置为构造函数prototype指向的对象</li><li>让函数的this指向这个新对象，执行构造函数的代码，为这个新对象添加属性</li><li>返回新对象</li></ol><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>运行时代码中的某些特定部分中变量，函数和对象的可用范围</p><p>作用是让**不同范围内的变量互不干扰</p><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>保存变量的使用顺序的一个链，被称为作用域链。每个函数在定义的时候，就一定规划好了自己查找变量的一个路线图，就是作用域链。</p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">func()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        test()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> c = <span class="built_in">this</span>.a</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>,<span class="string">&quot;as&quot;</span>)<span class="comment">//window</span></span><br><span class="line">            <span class="keyword">return</span> c</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn=obj2.foo();</span><br><span class="line"><span class="built_in">console</span>.log(fn(),<span class="string">&quot;asd&quot;</span>)</span><br></pre></td></tr></table></figure><h5 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h5><p><a href="https://blog.csdn.net/MiemieWan/article/details/110471580">https://blog.csdn.net/MiemieWan/article/details/110471580</a></p><h5 id="bind-call-apply-都是改变this-，传参不同"><a href="#bind-call-apply-都是改变this-，传参不同" class="headerlink" title="bind/call/apply 都是改变this ，传参不同"></a>bind/call/apply 都是改变this ，传参不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;小王&quot;</span>, age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;小张&#x27;</span>,</span><br><span class="line">    <span class="attr">objAge</span>: <span class="built_in">this</span>.age,</span><br><span class="line">    <span class="attr">myfun</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;年龄&quot;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.objAge)</span><br><span class="line">obj.myfun()</span><br><span class="line">obj.myfun.call(<span class="built_in">window</span>) </span><br><span class="line">obj.myfun.apply(<span class="built_in">window</span>)</span><br><span class="line">obj.myfun.bind(<span class="built_in">window</span>)()<span class="comment">//bind返回的是一个函数，需要调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2022/03/19/JS/image-20220331230001023.png" alt="image-20220331230001023"></p><p><img src="/2022/03/19/JS/image-20220331230051295.png" alt="image-20220331230051295"></p><h5 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h5><h6 id="var-gt-let-const"><a href="#var-gt-let-const" class="headerlink" title="var-&gt;let/const"></a>var-&gt;let/const</h6><p>var定义的变量，没有块的概念，可以跨块访问，不能跨函数访问。var可以先使用，后声明，因为存在<strong>变量提升</strong>。可以在相同作用域重复声明同一个变量。</p><p>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。必须先声明后使用。不能在同一作用域中重复声明</p><p>const用来定义常量，使用时必须初始化（即必须赋值），只能在块作用域里访问，且不能修改。不能在同一作用域中重复声明。</p><p><strong>变量提升(Hoisting)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前上下文中，所有带var和function关键字的进行提前的声明或者定义。</span><br><span class="line"></span><br><span class="line">- var：只声明不定义；</span><br><span class="line">- function：声明+定义；函数正题剪切过去</span><br><span class="line"></span><br><span class="line">变量提升和JS的编译过程密切相关，JS的编译阶段，会搜集所有的变量声明，并且提前让声明生效。变量提升阶段处理过的事情，代码执行阶段不会重复处理。</span><br></pre></td></tr></table></figure><p>JS只会提升声明，不会提升初始化，如果一个变量先被使用再被声明和赋值的话，使用时的值是undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*先使用再声明、赋值*/</span></span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// Returns undefined</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line">num = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/*先赋值再使用再声明*/</span></span><br><span class="line">num = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num); <span class="comment">// returns 6</span></span><br><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a); <span class="comment">// function a () &#123;&#125;</span></span><br><span class="line">   <span class="built_in">console</span>.log(b);  <span class="comment">// undefined</span></span><br><span class="line">   <span class="keyword">var</span> b = <span class="number">234</span>; </span><br><span class="line">   <span class="built_in">console</span>.log(b); <span class="comment">// 234</span></span><br><span class="line">   a = <span class="number">123</span>; </span><br><span class="line">   <span class="built_in">console</span>.log(a); <span class="comment">// 123</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;&#125;  <span class="comment">// 预编译时函数声明已经提升</span></span><br><span class="line">   <span class="keyword">var</span> a; <span class="comment">// 预编译时变量声明已经提升</span></span><br><span class="line">   b = <span class="number">234</span>;</span><br><span class="line">   <span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">//函数表达式不能提升</span></span><br><span class="line">   <span class="built_in">console</span>.log(a);  <span class="comment">// 123</span></span><br><span class="line">   <span class="built_in">console</span>.log(b);  <span class="comment">// function () &#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line"><span class="number">1</span>：创建AO对象，执行期上下文</span><br><span class="line">AO &#123;&#125;</span><br><span class="line"><span class="number">2</span>:找形参和变量声明，将变量和形参名作为AO属性名，值为<span class="literal">undefined</span></span><br><span class="line">AO &#123;</span><br><span class="line"> <span class="attr">a</span>:<span class="literal">undefined</span>,</span><br><span class="line"> <span class="attr">b</span>:<span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>:将实参值和形参统一</span><br><span class="line">AO &#123;</span><br><span class="line"> <span class="attr">a</span>: <span class="number">1</span>, <span class="comment">// a为形参,1为实参</span></span><br><span class="line"> <span class="attr">b</span>:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>: 在函数体里面找函数声明，值赋予函数体</span><br><span class="line">AO&#123;</span><br><span class="line"><span class="attr">a</span>:<span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="attr">b</span>:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x,y=<span class="keyword">function</span> anonymous1()&#123;x=<span class="number">2</span>&#125;</span>)</span>&#123;</span><br><span class="line">    x=<span class="number">3</span>;</span><br><span class="line">    y();</span><br><span class="line">    <span class="built_in">console</span>.log(x);   <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(test); // 1.打印下边整个test函数（在GO中找）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">test</span>) </span>&#123; <span class="comment">// 2.函数声明，整个函数包括函数体 先不看</span></span><br><span class="line">   <span class="built_in">console</span>.log(test);  <span class="comment">// 4.打印function test () &#123;&#125;(在AO中找)</span></span><br><span class="line">   <span class="keyword">var</span> test = <span class="number">234</span>; <span class="comment">// 5.（替换AO中test的值为234）</span></span><br><span class="line">   <span class="built_in">console</span>.log(test); <span class="comment">// 打印234</span></span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">&#125; </span><br><span class="line">test(<span class="number">1</span>); <span class="comment">// 3.调用函数（执行之前预编译先创建AO）</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="number">123</span>; <span class="comment">// 7.替换GO 中test的值为234</span></span><br><span class="line"><span class="built_in">console</span>.log(test);<span class="comment">// 打印123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析：</span></span><br><span class="line"><span class="number">1</span>：创建GO对象</span><br><span class="line">GO&#123;&#125;</span><br><span class="line"><span class="number">2</span>：找变量声明，将变量作为AO属性名，值为<span class="literal">undefined</span></span><br><span class="line">GO&#123;</span><br><span class="line"> <span class="attr">test</span>:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>:再找函数声明，值赋予函数体</span><br><span class="line">GO&#123;</span><br><span class="line"><span class="attr">test</span>:<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">test</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 整个函数体</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">GO对象创建完成，开始读代码，直到读到全局调用test函数时，函数预编译，开始创建AO对象</span><br><span class="line"><span class="number">1</span>：创建AO对象</span><br><span class="line">AO&#123;&#125;</span><br><span class="line"><span class="number">2</span>：找形参和变量声明，将变量和形参名作为AO属性名，值为<span class="literal">undefined</span></span><br><span class="line">AO&#123;</span><br><span class="line">  <span class="attr">test</span>:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>:将实参值和形参统一</span><br><span class="line">AO&#123;</span><br><span class="line">test：<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>：再函数体里面找函数声明，值赋予函数体</span><br><span class="line">AO&#123;</span><br><span class="line"><span class="attr">test</span>:<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844904192314703885">https://juejin.cn/post/6844904192314703885</a></p><p><strong>暂时性死区</strong></p><p>如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// TDZ开始</span></span><br><span class="line">    tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">    tmp = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h6><p><strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<code>this</code>，<code>arguments</code>，<code>super</code>或<code>new.target</code>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><p><a href="https://cloud.tencent.com/developer/article/1495550">JS箭头函数之：为何用？怎么用？何时用？ - 云+社区 - 腾讯云 (tencent.com)</a></p><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的this值：</p><h6 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> getFinalPrice = <span class="function"><span class="keyword">function</span> (<span class="params">price, tax</span>) </span>&#123;</span><br><span class="line">    tax = tax || <span class="number">0.7</span></span><br><span class="line">    <span class="keyword">return</span> price + price * tax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">var</span> getFinalPrice =<span class="function">(<span class="params">price, tax = <span class="number">0.7</span></span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> price + price * tax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="Spread-Rest操作符"><a href="#Spread-Rest操作符" class="headerlink" title="Spread/Rest操作符"></a>Spread/Rest操作符</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x,y,z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">foo(...arr); <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rest，可以简单理解为合并</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><h6 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: a1, <span class="attr">b</span>: b1, <span class="attr">c</span>: c1 &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(a1, b1, c1) <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="comment">// let &#123; a, b, c &#125; = obj // 等同上面</span></span><br><span class="line"><span class="comment">// console.log(a, b, c) // 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> [d, e, f] = arr</span><br><span class="line"><span class="built_in">console</span>.log(d, e, f) <span class="comment">//1 2 3 </span></span><br></pre></td></tr></table></figure><h6 id="模板语法和分隔符"><a href="#模板语法和分隔符" class="headerlink" title="模板语法和分隔符"></a>模板语法和分隔符</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&#x27;Barret&#x27;</span>;</span><br><span class="line"><span class="comment">// ``作为分隔符，$&#123; ... &#125;用来渲染一个变量</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hi <span class="subst">$&#123;user&#125;</span>!`</span>); </span><br></pre></td></tr></table></figure><h6 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h6><p>是异步编程的一种解决方案，比传统的解决方案（回调函数）更加合理和更加强大。</p><p><code>promise</code>对象仅有三种状态</p><ul><li><code>pending</code>（进行中）</li><li><code>fulfilled</code>（已成功）</li><li><code>rejected</code>（已失败）</li><li>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</li><li>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</li></ul><p><img src="/2022/03/19/JS/image-20220327215640160.png" alt="image-20220327215640160"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>[promise的原理 - 青青-小草 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/cherryblog/p/8549405.html#:~:text=%E5%85%B6%E5%AE%9E">https://www.cnblogs.com/cherryblog/p/8549405.html#:~:text=其实</a> promise 原理说起来并不难，它内部有三个状态，分别是 pending ， fulfilled 和 rejected,fulfill （成功）时变为 fulfilled ，当对象 reject （失败）时变为 rejected 。)</p><p><code>Promise</code>构建出来的实例存在以下方法：</p><ul><li>then()</li><li>catch()</li><li>finally()</li></ul><p><strong>then（）</strong></p><p><code>then</code>是实例状态发生改变时的回调函数，第一个参数是<code>resolved</code>状态的回调函数，第二个参数是<code>rejected</code>状态的回调函数</p><p><code>then</code>方法返回的是一个新的<code>Promise</code>实例，也就是<code>promise</code>能链式书写的原因</p><p><code>catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数，一般来说，使用<code>catch</code>方法代替<code>then()</code>第二个参数</p><h6 id="async-await是什么？（ES7）"><a href="#async-await是什么？（ES7）" class="headerlink" title="async/await是什么？（ES7）"></a>async/await是什么？（ES7）</h6><p>是promise的语法糖，用async(异步)声明一个异步函数没然后再用await（等待）等待一步结果，把以前then链的结果直接放在wait。async和await关键字让我们可以用一种更简洁的方式写出基于Promise的异步行为，而无需可以地链式调用promise。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。</p><p><a href="https://juejin.cn/post/6844904175071936519">Async / Await / Generator 实现原理 - 掘金 (juejin.cn)</a></p><p><strong>Async/Await 7如何通过同步的方式实现异步</strong></p><h6 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h6><h6 id="Proxy与Reflect"><a href="#Proxy与Reflect" class="headerlink" title="Proxy与Reflect"></a>Proxy与Reflect</h6><h6 id="for……of-for…"><a href="#for……of-for…" class="headerlink" title="for……of /for…"></a>for……of /for…</h6><h6 id="…in"><a href="#…in" class="headerlink" title="…in"></a>…in</h6><p>for in 里面的key是数组的下标，for of里面的key是数组下标所对应的值。</p><p>for in 可以直接遍历对象，但是for of 不行（如果对象本身定义了迭代器的话就可以遍历）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">b</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">c</span>:<span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);<span class="comment">//a b c</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]);<span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);<span class="comment">//Uncaught TypeError: obj is not iterable</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]);<span class="comment">//Uncaught TypeError: obj is not iterable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key,value] <span class="keyword">of</span> <span class="built_in">Object</span>.entires(obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key,value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。  (属性名)</span><br><span class="line"><span class="built_in">Object</span>.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<span class="keyword">for</span>...in循环的顺序相同 ( 区别在于 <span class="keyword">for</span>-<span class="keyword">in</span> 循环枚举原型链中的属性 )  （属性值）</span><br><span class="line"><span class="built_in">Object</span>.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <span class="keyword">for</span>...in 循环遍历该对象时返回的顺序一致（区别在于 <span class="keyword">for</span>-<span class="keyword">in</span> 循环还会枚举原型链中的属性）。 (键值对)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="迭代器Iterators"><a href="#迭代器Iterators" class="headerlink" title="迭代器Iterators"></a><strong>迭代器Iterators</strong></h6><p>迭代器允许每次访问数据集合的一个元素,当指针指向数据集合最后一个元素时，迭代器便会退出。他提供了next（）函数来遍历一个序列，这个放回返回一盒包含done和value属性的对象。</p><p>[Symbol.iterator] ()可被用于返回一个迭代器对象。</p><p><strong>数组默认就是一个迭代器</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>];</span><br><span class="line"><span class="keyword">var</span> itr = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"> </span><br><span class="line">itr.next(); <span class="comment">// &#123; value: 11, done: false &#125;</span></span><br><span class="line">itr.next(); <span class="comment">// &#123; value: 12, done: false &#125;</span></span><br><span class="line">itr.next(); <span class="comment">// &#123; value: 13, done: false &#125;</span></span><br><span class="line">itr.next(); <span class="comment">// &#123; value: undefined, done:true&#125;</span></span><br></pre></td></tr></table></figure><p>模拟一个next方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</span><br><span class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="生成器generator"><a href="#生成器generator" class="headerlink" title="生成器generator"></a>生成器generator</h6><h6 id="set"><a href="#set" class="headerlink" title="set"></a>set</h6><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><h6 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h6><h6 id="类与超类"><a href="#类与超类" class="headerlink" title="类与超类"></a>类与超类</h6><h5 id="事件循环Event-loop"><a href="#事件循环Event-loop" class="headerlink" title="事件循环Event loop"></a>事件循环Event loop</h5><p>JS是一门单线程的语言，同一时间就只能做一件事情，所以，为了实现单线程任务不阻塞的方法就是事件循环。js的任务有两种，同步任务和异步任务，同步任务就是立即执行的任务，异步任务就是异步执行的任务，比如ajax请求，setTimout定时函数。任务进入到执行栈之后，就会判断他是同步任务还是异步任务，如果是同步任务，就会进入到主线程里面，如果是异步任务就会进入到任务队列里面，主线程里面的同步任务执行为空，就会去任务列队读取对应的异步任务，再推入到主线程执行。这个过程的不断重复就是事件循环。</p><h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><p>原理是找到不再继续使用的变量，释放其内存。垃圾回收器会按照固定的时间间隔或者是代码预定的时间，周期性的执行这一操作。全局变量和局部变量。两种：标记清除（主要思想是给当前不使用的值加上标记，然后再回收他的内存;）、引用计数(跟踪记录所有值被引用的次数;这个值的引用次数为1，这个a值又被赋值给另一个变量b，这时引用次数+1;但当b赋另外的值，引用次数-1;当值的引用书为0，说明没有办法再访问这个值，这时就可以将内存回收了)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h5&gt;&lt;p&gt;基本类型&lt;/p&gt;
&lt;p&gt;Number，String，Boolean，Symbol，null，undefined&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>HTML5与css3</title>
    <link href="http://example.com/2022/03/17/HTML5/"/>
    <id>http://example.com/2022/03/17/HTML5/</id>
    <published>2022-03-17T07:40:05.000Z</published>
    <updated>2022-04-11T03:02:52.737Z</updated>
    
    <content type="html"><![CDATA[<h4 id="HTML与浏览器"><a href="#HTML与浏览器" class="headerlink" title="HTML与浏览器"></a>HTML与浏览器</h4><h5 id="html5-语义化"><a href="#html5-语义化" class="headerlink" title="html5 语义化"></a>html5 语义化</h5><p>合理正确的使用语义化的标签来创建页面</p><p>语义化标签：header，footer，nav，main，article，section，aside</p><p><strong>优点</strong> </p><p>易读，利于维护，结构，有利于搜索引擎优化（SEO）</p><h5 id="行内元素，块级元素"><a href="#行内元素，块级元素" class="headerlink" title="行内元素，块级元素"></a>行内元素，块级元素</h5><p><strong>行内</strong></p><p>a, span, label, strong, em, br, img, input, select, textarea, cite（引用）</p><p><strong>块级元素</strong></p><p>div, h1~h6, p, form, ul, li, ol, dl, address, hr, menu, table, fieldset-form(控制组)</p><p>在标准文档流里面，块级元素具有以下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">① 总是在新行上开始，占据一整行；</span><br><span class="line">② 高度，行高以及外边距和内边距都可控制；</span><br><span class="line">③ 宽度缺省是它父级元素的100%，除非设定一个宽度</span><br><span class="line">④ 它可以容纳内联元素和其他块元素。</span><br></pre></td></tr></table></figure><p>行内元素的特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">① 和其他元素都在一行上，遇到父级元素边界会自动换行</span><br><span class="line"> ；</span><br><span class="line">② 高，行高及外边距和内边距（左右）部分可改变；</span><br><span class="line">③ 宽度只与内容有关；</span><br><span class="line">④ 行内元素只能容纳文本或者其他行内元素。</span><br><span class="line">不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变，内联元素可以设置外边界，但是外边界不对上下起作用，只能对左右起作用，也可以设置内边界，但是内边界在ie6中不对上下起作用，只能对左右起作用</span><br></pre></td></tr></table></figure><h5 id="跨标签页通信"><a href="#跨标签页通信" class="headerlink" title="跨标签页通信"></a>跨标签页通信</h5><p><a href="https://juejin.cn/post/6844903811232825357">面试官：前端跨页面通信，你知道哪些方法？ - 掘金 (juejin.cn)</a></p><p><strong>理解</strong></p><p><img src="/2022/03/17/HTML5/image-20220319102503915.png" alt="image-20220319102503915"></p><p>跨标签如上图，假如这是两个有联系的页面，那么我改变页面1的信息，页面二的信息会也改变。</p><p><strong>同源页面间的跨页面通信</strong></p><p>广播式通信：一个页面将小子通知给一个“中央站”，再由“中央站”通知给各个页面。</p><ol><li> BroadCast Channel</li></ol><p><a href="https://juejin.cn/post/6844903811228663815">【3分钟速览】前端广播式通信：Broadcast Channel - 掘金 (juejin.cn)</a></p><ol start="2"><li>Service Worker </li></ol><p><a href="https://juejin.cn/post/6844903588691443725">【PWA学习与实践】(3) 让你的WebApp离线可用 - 掘金 (juejin.cn)</a></p><ol start="3"><li>LocalStorage</li></ol><p><strong>非同源页面之间的通信</strong></p><h5 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h5><p>前端调用的后端的接口不属于同一个域（协议、域名、端口、子域名不同）</p><h5 id="history-hash"><a href="#history-hash" class="headerlink" title="history/hash"></a>history/hash</h5><p><a href="https://blog.csdn.net/Charissa2017/article/details/104779412">前端路由的两种模式：hash模式和 history模式_蒲公英芽的博客-CSDN博客_history</a></p><h5 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h5><p>DOM模型不仅描述了文档的结构，还定义了结点对象的行为，利用对象的方法和属性，可以方便地访问、修改、添加和删除DOM树的结点和内容。</p><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><p><a href="https://javascript.ruanyifeng.com/dom/event.html">事件模型 – JavaScript 标准参考教程（alpha） (ruanyifeng.com)</a></p><h5 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h5><p><a href="https://juejin.cn/post/6844903593275817998">彻底理解浏览器的缓存机制 - 掘金 (juejin.cn)</a></p><h5 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h5><p><a href="https://xie.infoq.cn/article/5d36d123bfd1c56688e125ad3">Chrome浏览器架构_chrome_曲迪_InfoQ写作平台</a></p><h5 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h5><p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：现代网络浏览器幕后揭秘 - HTML5 Rocks</a></p><h5 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><p><a href="https://segmentfault.com/a/1190000020231307">深入了解 JavaScript 内存泄露 - SegmentFault 思否</a></p><p><strong>浏览器工作原理与实践</strong></p><p><a href="https://blog.poetries.top/browser-working-principle/guide/part5/lesson22.html#%E4%BB%80%E4%B9%88%E6%98%AF-dom">DOM树：JavaScript是如何影响DOM树构建的 | 浏览器工作原理与实践 (poetries.top)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;HTML与浏览器&quot;&gt;&lt;a href=&quot;#HTML与浏览器&quot; class=&quot;headerlink&quot; title=&quot;HTML与浏览器&quot;&gt;&lt;/a&gt;HTML与浏览器&lt;/h4&gt;&lt;h5 id=&quot;html5-语义化&quot;&gt;&lt;a href=&quot;#html5-语义化&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="HTML与浏览器" scheme="http://example.com/tags/HTML%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
</feed>
